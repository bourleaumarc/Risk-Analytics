library(extRemes)
list_max_sea_levels <- unlist(venice_max$max_sea_level)
gev_fix <- fevd(list_max_sea_levels, type = "GEV", time.units= "year")
plot(gev_fix) ; gev_fix$results$par
# Fit a GEV model with time-varying location parameters
gev_time_varying <- fevd(list_max_sea_levels, type = "GEV", time.units = "year", rperiods = c(13), location.fun= ~year)
library(extRemes)
list_max_sea_levels <- unlist(venice_max$max_sea_level)
gev_fix <- fevd(list_max_sea_levels, type = "GEV", time.units= "year")
plot(gev_fix) ; gev_fix$results$par
# Fit a GEV model with time-varying location parameters
gev_time_varying <- fevd(list_max_sea_levels, type = "GEV", time.units = "year", rperiods = c(2010:2022), location.fun= ~year)
library(extRemes)
list_max_sea_levels <- unlist(venice_max$max_sea_level)
gev_fix <- fevd(list_max_sea_levels, type = "GEV", time.units= "year")
plot(gev_fix) ; gev_fix$results$par
# Fit a GEV model with time-varying location parameters
gev_time_varying <- fevd(list_max_sea_levels, type = "GEV", time.units = "year", rperiods = c(1, 2, 5, 13), location.fun= ~year)
library(extRemes)
list_max_sea_levels <- unlist(venice_max$max_sea_level)
gev_fix <- fevd(list_max_sea_levels, type = "GEV", time.units= "year")
plot(gev_fix) ; gev_fix$results$par
# Fit a GEV model with time-varying location parameters
gev_time_varying <- fevd(list_max_sea_levels, type = "GEV", time.units = "year", location.fun= ~year)
plot(gev_time_varying) ; gev_time_varying$results$par
??fevd
#compare models with LRT
lrtresults <- lr.test(gev_time_varying, gev_fix)
print(lrtresults)
library(extRemes)
list_max_sea_levels <- unlist(venice_max$max_sea_level)
gev_fix <- fevd(list_max_sea_levels, type = "GEV", time.units= "year")
plot(gev_fix) ; gev_fix$results$par
# Fit a GEV model with time-varying location parameters
gev_time_varying <- fevd(list_max_sea_levels, type = "GEV", location.fun= ~year, time.units = "year", rperiod = 13)
library(extRemes)
list_max_sea_levels <- unlist(venice_max$max_sea_level)
gev_fix <- fevd(list_max_sea_levels, type = "GEV", time.units= "year")
plot(gev_fix) ; gev_fix$results$par
# Fit a GEV model with time-varying location parameters
gev_time_varying <- fevd(list_max_sea_levels, type = "GEV", location.fun= ~year, time.units = "year", rperiods = 13)
return.level(gev_fix)
# Use ci()
# Use lr.test to compare both models
?fevd
library(extRemes)
list_max_sea_levels <- unlist(venice_max$max_sea_level)
gev_fix <- fevd(list_max_sea_levels, type = "GEV", time.units= "year")
plot(gev_fix) ; gev_fix$results$par
# Fit a GEV model with time-varying location parameters
gev_time_varying <- fevd(list_max_sea_levels, type = "GEV", location.fun= ~year, time.units = "year")
plot(gev_time_varying) ; gev_time_varying$results$par
return.level(gev_fix)
# Use ci()
# Use lr.test to compare both models
?fevd
#compare models with LRT
lrtresults <- lr.test(gev_time_varying, gev_fix)
print(lrtresults)
#compare models with LRT
lr.test(gev_fix, gev_time_varying)
gev_time_varying <- fevd(list_max_sea_levels, type = "GEV", location.fun= ~year, time.units = "year")
plot(gev_time_varying) ; gev_time_varying$results$par
plot(gev_fix)
gev_fix$results$par
data(PORTw)
View(PORTw)
# First we unlist the max se
gev_fix2 <- fevd(venice_max, type = "GEV", time.units = "year")
gev_fix2 <- fevd(venice_max, type = "GEV", time.units = "year")
plot(gev_fix2)
# GEV model with varying time-location
?fevd
# Create linear model
mod1 <- lm(max_sea_level ~ year, data = venice_max)
summary(mod1)
# Predictions of 13 next years using the linear model
mod1_predict <- predict.lm(mod1,newdata=data.frame("year"=c(2010:2022)),se=T, interval = "confidence", level = 0.95)
mod1_predict
# Stored the predictions in a dataframe
venice_max_predict <- data.frame(
PredictedValues = mod1_predict) %>%
mutate(year = c(2010:2022))
haed(venice_max_predict)
# Stored the predictions in a dataframe
venice_max_predict <- data.frame(
PredictedValues = mod1_predict) %>%
mutate(year = c(2010:2022))
head(venice_max_predict)
#Plot the confidence intervals
plotCI(x = venice_max_predict$year,
y = venice_max_predict$PredictedValues.fit.fit,
li = venice_max_predict$PredictedValues.fit.lwr,
ui = venice_max_predict$PredictedValues.fit.upr)
#Create a new dataframe for the extreme values of 2010 - 2022 (table from Wikipedia)
max_real <- data.frame(year = c(2012, 2012, 2013, 2018, 2019, 2019, 2019, 2022), max_sea_level = c(143, 149, 143, 156, 187, 144, 154, 204))
ggplot() +
geom_ribbon(data = venice_max_predict, aes(x = year, ymin = PredictedValues.fit.lwr, ymax = PredictedValues.fit.upr), fill = "blue", alpha = 0.3) +
geom_point(data = max_real, aes(x = year, y = max_sea_level, color = "Observed", colour = "red"), alpha = 0.5) +
geom_point(data = venice_max_predict, aes(x = year, y = PredictedValues.fit.fit, color = "Predicted"), shape = 1) +
labs(title = "Real extreme values from 2010 to 2022 versus predicted values' confidence intervals", x = "Year", y = "Sea Level") +
scale_x_continuous(breaks = unique(c(venice_max_predict$year, max_real$year))) +
scale_color_manual(name = "Data Type", values = c("Observed" = "red", "Predicted" = "black"))
# Stored the predictions in a dataframe
venice_max_predict <- data.frame(
PredictedValues = mod1_predict) %>%
mutate(year = c(2010:2022))
head(venice_max_predict)
#Plot the confidence intervals
plotCI(x = venice_max_predict$year,
y = venice_max_predict$PredictedValues.fit.fit,
li = venice_max_predict$PredictedValues.fit.lwr,
ui = venice_max_predict$PredictedValues.fit.upr)
#Create a new dataframe for the extreme values of 2010 - 2022 (table from Wikipedia)
max_real <- data.frame(year = c(2012, 2012, 2013, 2018, 2019, 2019, 2019, 2022), max_sea_level = c(143, 149, 143, 156, 187, 144, 154, 204))
ggplot() +
geom_ribbon(data = venice_max_predict, aes(x = year, ymin = PredictedValues.fit.lwr, ymax = PredictedValues.fit.upr), fill = "blue", alpha = 0.3) +
geom_point(data = max_real, aes(x = year, y = max_sea_level, color = "Observed", colour = "red"), alpha = 0.5) +
geom_point(data = venice_max_predict, aes(x = year, y = PredictedValues.fit.fit, color = "Predicted"), shape = 1) +
labs(title = "Real extreme values from 2010 to 2022 versus predicted values' confidence intervals", x = "Year", y = "Sea Level") +
scale_x_continuous(breaks = unique(c(venice_max_predict$year, max_real$year))) +
scale_color_manual(name = "Data Type", values = c("Observed" = "red", "Predicted" = "black"))
# Create the ggplot object (as you've done before)
venice_plot <- ggplot() +
geom_ribbon(data = venice_max_predict, aes(x = year, ymin = PredictedValues.fit.lwr, ymax = PredictedValues.fit.upr), fill = "blue", alpha = 0.3) +
geom_point(data = max_real, aes(x = year, y = max_sea_level, color = "Observed"), alpha = 0.5) +
geom_point(data = venice_max_predict, aes(x = year, y = PredictedValues.fit.fit.fit, color = "Predicted"), shape = 1) +
labs(title = "Predicted yearly max values vs Observed values greater than 140cm", x = "Year", y = "Sea Level") +
scale_x_continuous(breaks = unique(c(venice_max_predict$year, max_real$year))) +
scale_color_manual(name = "Data Type", values = c("Observed" = "red", "Predicted" = "black")) +
theme(legend.title = element_blank())
# Convert the ggplot object to a Plotly interactive plot
interactive_venice_plot <- ggplotly(venice_plot)
interactive_venice_plot
venice_plot
# Create the ggplot object (as you've done before)
venice_plot <- ggplot() +
geom_ribbon(data = venice_max_predict, aes(x = year, ymin = PredictedValues.fit.lwr, ymax = PredictedValues.fit.upr), fill = "blue", alpha = 0.3) +
geom_point(data = max_real, aes(x = year, y = max_sea_level, color = "Observed"), alpha = 0.5) +
geom_point(data = venice_max_predict, aes(x = year, y = PredictedValues.fit.fit.fit, color = "Predicted"), shape = 1) +
labs(title = "Predicted yearly max values vs Observed values greater than 140cm", x = "Year", y = "Sea Level") +
scale_x_continuous(breaks = unique(c(venice_max_predict$year, max_real$year))) +
scale_color_manual(name = "Data Type", values = c("Observed" = "red", "Predicted" = "black")) +
theme(legend.title = element_blank())
# Convert the ggplot object to a Plotly interactive plot
interactive_venice_plot <- ggplotly(venice_plot)
#Plot the confidence intervals
plotCI(x = venice_max_predict$year,
y = venice_max_predict$PredictedValues.fit.fit,
li = venice_max_predict$PredictedValues.fit.lwr,
ui = venice_max_predict$PredictedValues.fit.upr)
venice_max_predict <- data.frame(
PredictedValues = mod1_predict) %>%
mutate(year = c(2010:2022))
head(venice_max_predict)
View(venice_max_predict)
# Create the ggplot object (as you've done before)
venice_plot <- ggplot() +
geom_ribbon(data = venice_max_predict, aes(x = year, ymin = PredictedValues.fit.lwr, ymax = PredictedValues.fit.upr), fill = "blue", alpha = 0.3) +
geom_point(data = max_real, aes(x = year, y = max_sea_level, color = "Observed"), alpha = 0.5) +
geom_point(data = venice_max_predict, aes(x = year, y = PredictedValues.fit.fit.fit, color = "Predicted"), shape = 1) +
labs(title = "Predicted yearly max values vs Observed values greater than 140cm", x = "Year", y = "Sea Level") +
scale_x_continuous(breaks = unique(c(venice_max_predict$year, max_real$year))) +
scale_color_manual(name = "Data Type", values = c("Observed" = "red", "Predicted" = "black")) +
theme(legend.title = element_blank())
# Convert the ggplot object to a Plotly interactive plot
interactive_venice_plot <- ggplotly(venice_plot)
# Create the ggplot object (as you've done before)
venice_plot <- ggplot() +
geom_ribbon(data = venice_max_predict, aes(x = year, ymin = PredictedValues.fit.lwr, ymax = PredictedValues.fit.upr), fill = "blue", alpha = 0.3) +
geom_point(data = max_real, aes(x = year, y = max_sea_level, color = "Observed"), alpha = 0.5) +
geom_point(data = venice_max_predict, aes(x = year, y = PredictedValues.fit.fit, color = "Predicted"), shape = 1) +
labs(title = "Predicted yearly max values vs Observed values greater than 140cm", x = "Year", y = "Sea Level") +
scale_x_continuous(breaks = unique(c(venice_max_predict$year, max_real$year))) +
scale_color_manual(name = "Data Type", values = c("Observed" = "red", "Predicted" = "black")) +
theme(legend.title = element_blank())
# Convert the ggplot object to a Plotly interactive plot
interactive_venice_plot <- ggplotly(venice_plot)
# Display the interactive plot
interactive_venice_plot
# Create the ggplot object
venice_plot <- ggplot() +
geom_ribbon(data = venice_max_predict, aes(x = year, ymin = PredictedValues.fit.lwr, ymax = PredictedValues.fit.upr), fill = "blue", alpha = 0.3, show.legend = TRUE, name = "Confidence Interval") +
geom_point(data = max_real, aes(x = year, y = max_sea_level, color = "Observed"), alpha = 0.5, show.legend = TRUE, name = "Observed") +
geom_point(data = venice_max_predict, aes(x = year, y = PredictedValues.fit.fit, color = "Predicted"), shape = 1, show.legend = TRUE, name = "Predicted") +
labs(title = "Predicted Yearly Max Values vs Observed Values (>140cm)", x = "Year", y = "Sea Level") +
scale_x_continuous(breaks = unique(c(venice_max_predict$year, max_real$year))) +
scale_color_manual(name = "Data Type", values = c("Observed" = "red", "Predicted" = "black")) +
theme(legend.title = element_blank())
# Convert the ggplot object to a Plotly interactive plot
interactive_venice_plot <- ggplotly(venice_plot)
# Display the interactive plot
interactive_venice_plot
# Stored the predictions in a dataframe
venice_max_predict <- data.frame(
PredictedValues = mod1_predict) %>%
mutate(year = c(2010:2022))
head(venice_max_predict)
#Plot the confidence intervals
plotCI(x = venice_max_predict$year,
y = venice_max_predict$PredictedValues.fit.fit,
li = venice_max_predict$PredictedValues.fit.lwr,
ui = venice_max_predict$PredictedValues.fit.upr)
#Create a new dataframe for the extreme values of 2010 - 2022 (table from Wikipedia)
max_real <- data.frame(year = c(2012, 2012, 2013, 2018, 2019, 2019, 2019, 2022), max_sea_level = c(143, 149, 143, 156, 187, 144, 154, 204))
# Create the ggplot object
venice_plot <- ggplot() +
geom_ribbon(data = venice_max_predict, aes(x = year, ymin = PredictedValues.fit.lwr, ymax = PredictedValues.fit.upr), fill = "blue", alpha = 0.3) +
geom_point(data = max_real, aes(x = year, y = max_sea_level, color = "Observed"), alpha = 0.5) +
geom_point(data = venice_max_predict, aes(x = year, y = PredictedValues.fit.fit, color = "Predicted"), shape = 1) +
labs(title = "Predicted yearly max values vs Observed values greater than 140cm", x = "Year", y = "Sea Level") +
scale_x_continuous(breaks = unique(c(venice_max_predict$year, max_real$year))) +
scale_color_manual(name = "Data Type", values = c("Observed" = "red", "Predicted" = "black")) +
theme(legend.title = element_blank())
# Convert the ggplot object to a Plotly interactive plot
interactive_venice_plot <- ggplotly(venice_plot)
# Display the interactive plot
interactive_venice_plot
# Load the necessary libraries
library(ggplot2)
library(plotly)
# ... (Your previous code for data preparation and ggplot)
# Create the ggplot object
venice_plot <- ggplot() +
geom_ribbon(data = venice_max_predict, aes(x = year, ymin = PredictedValues.fit.lwr, ymax = PredictedValues.fit.upr), fill = "blue", alpha = 0.3, show.legend = TRUE, name = "Confidence Interval") +
geom_point(data = max_real, aes(x = year, y = max_sea_level, color = "Observed"), alpha = 0.5, show.legend = TRUE, name = "Observed") +
geom_point(data = venice_max_predict, aes(x = year, y = PredictedValues.fit.fit, color = "Predicted"), shape = 1, show.legend = TRUE, name = "Predicted") +
labs(title = "Predicted Yearly Max Values vs Observed Values (>140cm)", x = "Year", y = "Sea Level") +
scale_x_continuous(breaks = unique(c(venice_max_predict$year, max_real$year))) +
scale_color_manual(name = "Data Type", values = c("Observed" = "red", "Predicted" = "black")) +
theme(legend.title = element_blank())
# Convert the ggplot object to a Plotly interactive plot
interactive_venice_plot <- ggplotly(venice_plot)
# Display the interactive plot
interactive_venice_plot
# Create the ggplot object
venice_plot <- ggplot() +
geom_point(data = max_real, aes(x = year, y = max_sea_level, color = "Observed"), alpha = 0.5, show.legend = TRUE, name = "Observed") +
geom_point(data = venice_max_predict, aes(x = year, y = PredictedValues.fit.fit, color = "Predicted"), shape = 1, show.legend = TRUE, name = "Predicted") +
labs(title = "Predicted Yearly Max Values vs Observed Values (>140cm)", x = "Year", y = "Sea Level") +
scale_x_continuous(breaks = unique(c(venice_max_predict$year, max_real$year))) +
scale_color_manual(name = "Data Type", values = c("Observed" = "red", "Predicted" = "black")) +
theme(legend.title = element_blank())
# Convert the ggplot object to a Plotly interactive plot
interactive_venice_plot <- ggplotly(venice_plot)
# Add the confidence interval as a separate trace
interactive_venice_plot <- interactive_venice_plot %>%
add_ribbons(data = venice_max_predict, x = ~year, ymin = ~PredictedValues.fit.lwr, ymax = ~PredictedValues.fit.upr, color = I("blue"), showlegend = TRUE, name = "Confidence Interval")
# Display the interactive plot
interactive_venice_plot
# Stored the predictions in a dataframe
venice_max_predict <- data.frame(
PredictedValues = mod1_predict) %>%
mutate(year = c(2010:2022))
head(venice_max_predict)
#Plot the confidence intervals
plotCI(x = venice_max_predict$year,
y = venice_max_predict$PredictedValues.fit.fit,
li = venice_max_predict$PredictedValues.fit.lwr,
ui = venice_max_predict$PredictedValues.fit.upr)
#Create a new dataframe for the extreme values of 2010 - 2022 (table from Wikipedia)
max_real <- data.frame(year = c(2012, 2012, 2013, 2018, 2019, 2019, 2019, 2022), max_sea_level = c(143, 149, 143, 156, 187, 144, 154, 204))
# Create the ggplot object
venice_plot <- ggplot() +
geom_point(data = max_real, aes(x = year, y = max_sea_level, color = "Observed"), alpha = 0.5, show.legend = TRUE, name = "Observed") +
geom_point(data = venice_max_predict, aes(x = year, y = PredictedValues.fit.fit, color = "Predicted"), shape = 1, show.legend = TRUE, name = "Predicted") +
labs(title = "Predicted Yearly Max Values vs Observed Values (>140cm)", x = "Year", y = "Sea Level") +
scale_x_continuous(breaks = unique(c(venice_max_predict$year, max_real$year))) +
scale_color_manual(name = "Data Type", values = c("Observed" = "red", "Predicted" = "black")) +
theme(legend.title = element_blank())
# Convert the ggplot object to a Plotly interactive plot
interactive_venice_plot <- ggplotly(venice_plot)
# Add the confidence interval as a separate trace
interactive_venice_plot <- interactive_venice_plot %>%
add_ribbons(data = venice_max_predict, x = ~year, ymin = ~PredictedValues.fit.lwr, ymax = ~PredictedValues.fit.upr, color = I("blue"), showlegend = TRUE, name = "Confidence Interval")
# Display the interactive plot
interactive_venice_plot
# GEV model with varying time-location
?fevd
# GEV model with varying time-location
gev_time_varying <- fevd(venice_max, venice_max$max_sea_level, location.fun = ~year)
View(venice_max)
length(venice_max$max_sea_level)
library(ismev)
library(VGAM)
library(tidyverse)
library(plotly)
library(plotrix)
library(scales)
library(extRemes)
# GEV model with varying time-location
gev_time_varying <- fevd(venice_max, venice_max$max_sea_level, location.fun = ~year)
# GEV model with varying time-location
gev_time_varying <- fevd(venice_max, venice_max$max_sea_level, type = "GEV", time.units= "year" location.fun = ~year)
# GEV model with varying time-location
gev_time_varying <- fevd(venice_max, venice_max$max_sea_level, type = "GEV", time.units= "year", location.fun = ~year)
gev_fix2 <-  fevd(venice_max, type = "GEV", time.units= "year")
data(PORTw)
fit2 <- fevd(TMX1, PORTw, location.fun=~AOindex, units="deg C")
fit2
plot(fit2)
TMX1
fit2 <- fevd(TMX1, PORTw, location.fun=~AOindex, units="deg C")
View(PORTw)
# GEV model with varying time-location
gev_time_varying <- fevd(max_sea_level, venice_max, type = "GEV", time.units= "year", location.fun = ~year)
gev_time_varying <- fevd(venice_max$max_sea_level, venice_max, type = "GEV", time.units= "year", location.fun = ~year)
plot(gev_time_varying) ; gev_time_varying$results$par
plot(gev_time_varying) ; gev_time_varying$results$par
plot(gev_fix) ; gev_fix$results$par ; return.leve(gev_fix)
plot(gev_fix) ; gev_fix$results$par ; return.level(gev_fix)
plot(gev_time_varying) ; gev_time_varying$results$par ; return.level(gev_time_varying)
# Compare the two models using likelihood ratio test
lr.test(gev_fix, gev_time_varying)
lrtresults <- lr.test(gev_time_varying, gev_fix)
print(lrtresults)
View(venice)
gev_time_varying <- fevd(venice$sea_level, venice, type = "GEV", time.units= "year", location.fun = ~year)
View(venice)
gev_time_varying <- fevd(venice$sealevel, venice, type = "GEV", time.units= "year", location.fun = ~year)
plot(gev_time_varying) ; gev_time_varying$results$par ; return.level(gev_time_varying)
gev_time_varying$results$par
lr.test(gev_fix, gev_time_varying) # we can't reject the null hypothesis, this doesn't make sense..
View(PORTw)
gev_time_varying <- fevd(venice_max$max_sea_level, venice_max, type = "GEV", time.units= "year", location.fun = ~year)
plot(gev_time_varying) ; gev_time_varying$results$par ; return.level(gev_time_varying)
gev_time_varying$results$par
lr.test(gev_fix, gev_time_varying) # we can't reject the null hypothesis, this doesn't make sense..
gev_time_varying <- fevd(venice_max$max_sea_level, venice_max, type = "Gumbel", time.units= "year", location.fun = ~year)
gev_time_varying$results$par
lr.test(gev_fix, gev_time_varying) # we can't reject the null hypothesis, this doesn't make sense..
# Compute confidence interval
ci(gev_fix)
# Compute confidence interval
ci(gev_fix, type= "parameter")
gev_fix_gumbel <- fevd(list_max_sea_levels, type = "Gumbel", time.units= "year")
gev_fix$results$par ; gev_fix_gumbel$results$par
gev_fix_gumbel$results$par
ci(gev_fix, type= "parameter"
ci(gev_fix, type= "parameter")
gev_fix <- fevd(list_max_sea_levels, type = "GEV", time.units= "year")
plot(gev_fix) ; gev_fix$results$par ; return.level(gev_fix) # shape is almost equal to 0.
# Compute confidence interval
ci(gev_fix, type= "parameter")
gev_time_varying <- fevd(venice_max$max_sea_level, venice_max, type = "GEV", time.units= "year", location.fun = ~year)
lr.test(gev_fix, gev_time_varying) # we can't reject the null hypothesis, this doesn't make sense..
# First we unlist our data frame
list_max_sea_levels <- unlist(venice_max$max_sea_level)
# GEV model with fixed location
gev_fix <- fevd(list_max_sea_levels, type = "GEV", time.units= "year")
plot(gev_fix) ; gev_fix$results$par ; return.level(gev_fix) # shape is almost equal to 0.
# Compute confidence interval
ci(gev_fix, type= "parameter") # we assume that it's a Gumbel distribution
# GEV model with varying time-location on all data points
gev_time_varying <- fevd(venice_max$max_sea_level, venice_max, type = "GEV", time.units= "year", location.fun = ~year)
plot(gev_time_varying) ; gev_time_varying$results$par ; return.level(gev_time_varying)
# Compare the two models using likelihood ratio test: Ho: no significant differnce in model fit H1: there is a significant difference in model fit between the two models.
# We need to se
gev_time_varying <- fevd(venice_max$max_sea_level, venice_max, type = "GEV", time.units= "year", location.fun = ~year)
lr.test(gev_fix, gev_time_varying) # we can't reject the null hypothesis, this doesn't make sense..
lr.test(gev_fix, gev_time_varying) # we can't reject the null hypothesis, this doesn't make sense..
# First we unlist our data frame
list_max_sea_levels <- unlist(venice_max$max_sea_level)
# GEV model with fixed location
gev_fix <- fevd(list_max_sea_levels, type = "GEV", time.units= "year")
plot(gev_fix) ; gev_fix$results$par ; return.level(gev_fix) # shape is almost equal to 0.
# Compute confidence interval
ci(gev_fix, type= "parameter") # CI includes 0
# GEV model with varying time-location
gev_time_varying <- fevd(venice_max$max_sea_level, venice_max, type = "GEV", time.units= "year", location.fun = ~year)
plot(gev_time_varying) ; gev_time_varying$results$par ; return.level(gev_time_varying)
# Compare the two models using likelihood ratio test: Ho: no significant difference in model fit H1: there is a significant difference in model fit between the two models.
lr.test(gev_fix, gev_time_varying) # we can't reject the null hypothesis, this doesn't make sense..
lr.test(gev_fix, gev_time_varying) # we can't reject the null hypothesis, this doesn't make sense..
alpha <- 0.10  # 90% significance level
critical_value <- qchisq(1 - alpha, df = 1)  # Chi-squared critical value
lrt_result <- lr.test(gev_fix, gev_time_varying, critical = critical_value)
lrt_result
# Compare the two models using likelihood ratio test: Ho: no significant difference in model fit H1: there is a significant difference in model fit between the two models.
lr.test <- lr.test(gev_fix, gev_time_varying) # we can almost reject the null hypothesis at 95% significant level, which make sense as we have indications that the distribution is non-stationary
plot(lr.test)
# Compare the two models using likelihood ratio test: Ho: no significant difference in model fit H1: there is a significant difference in model fit between the two models.
lrt_result <- lr.test(gev_fix, gev_time_varying) # we can almost reject the null hypothesis at 95% significant level, which make sense as we have indications that the distribution is non-stationary
plot(lrt_result)
knitr::opts_chunk$set(echo = TRUE)
library(ismev)
library(VGAM)
library(tidyverse)
library(plotly)
library(plotrix)
library(scales)
library(extRemes)
# Read the Data
venice <- venice90
# Using block maxima approach to have the maximum sea level per year
venice_max <- venice %>%
group_by(year) %>%
summarise(max_sea_level = max(sealevel))
head(venice_max)
plot_ly(venice_max, x = ~year, y = ~max_sea_level, type = 'scatter', mode = 'markers', name = 'Max Value') %>% layout(title = "Maximum Value per year", xaxis = list(title="Year"), yaxis = list(title="Maximum Value"))  %>% add_segments(x = 1940, xend = 2009, y = 140, yend = 140, line = list(color = 'red', width = 2))
# Create linear model
mod1 <- lm(max_sea_level ~ year, data = venice_max)
summary(mod1)
# Predictions of 13 next years using the linear model
mod1_predict <- predict.lm(mod1,newdata=data.frame("year"=c(2010:2022)),se=T, interval = "confidence", level = 0.95)
mod1_predict
# Stored the predictions in a dataframe
venice_max_predict <- data.frame(
PredictedValues = mod1_predict) %>%
mutate(year = c(2010:2022))
head(venice_max_predict)
#Plot the confidence intervals
plotCI(x = venice_max_predict$year,
y = venice_max_predict$PredictedValues.fit.fit,
li = venice_max_predict$PredictedValues.fit.lwr,
ui = venice_max_predict$PredictedValues.fit.upr)
#Create a new dataframe for the extreme values of 2010 - 2022 (table from Wikipedia)
max_real <- data.frame(year = c(2012, 2012, 2013, 2018, 2019, 2019, 2019, 2022), max_sea_level = c(143, 149, 143, 156, 187, 144, 154, 204))
# Create the ggplot object
venice_plot <- ggplot() +
geom_point(data = max_real, aes(x = year, y = max_sea_level, color = "Observed"), alpha = 0.5, show.legend = TRUE, name = "Observed") +
geom_point(data = venice_max_predict, aes(x = year, y = PredictedValues.fit.fit, color = "Predicted"), shape = 1, show.legend = TRUE, name = "Predicted") +
labs(title = "Predicted Yearly Max Values vs Observed Values (>140cm)", x = "Year", y = "Sea Level") +
scale_x_continuous(breaks = unique(c(venice_max_predict$year, max_real$year))) +
scale_color_manual(name = "Data Type", values = c("Observed" = "red", "Predicted" = "black")) +
theme(legend.title = element_blank())
# Convert the ggplot object to a Plotly interactive plot
interactive_venice_plot <- ggplotly(venice_plot)
# Add the confidence interval as a separate trace
interactive_venice_plot <- interactive_venice_plot %>%
add_ribbons(data = venice_max_predict, x = ~year, ymin = ~PredictedValues.fit.lwr, ymax = ~PredictedValues.fit.upr, color = I("blue"), showlegend = TRUE, name = "Confidence Interval")
# Display the interactive plot
interactive_venice_plot
# First we unlist our data frame
list_max_sea_levels <- unlist(venice_max$max_sea_level)
# GEV model with fixed location
gev_fix <- fevd(list_max_sea_levels, type = "GEV", time.units= "year")
plot(gev_fix) ; gev_fix$results$par ; return.level(gev_fix) # shape is almost equal to 0.
# Compute confidence interval
ci(gev_fix, type= "parameter") # CI includes 0
# GEV model with varying time-location
gev_time_varying <- fevd(venice_max$max_sea_level, venice_max, type = "GEV", time.units= "year", location.fun = ~year)
plot(gev_time_varying) ; gev_time_varying$results$par ; return.level(gev_time_varying)
# Compare the two models using likelihood ratio test: Ho: no significant difference in model fit H1: there is a significant difference in model fit between the two models.
lrt_result <- lr.test(gev_fix, gev_time_varying) # we can almost reject the null hypothesis at 95% significant level, which make sense as we have indications that the distribution is non-stationary
plot(lrt_result)
lrt_result <- lr.test(gev_fix, gev_time_varying) # we can almost reject the null hypothesis at 95% significant level, which make sense as we have indications that the distribution is non-stationary
plot(lrt_result)
# Compare the two models using likelihood ratio test: Ho: no significant difference in model fit H1: there is a significant difference in model fit between the two models.
lrt_result2 <- lr.test(gev_fix, gev_time_varying) # we can almost reject the null hypothesis at 95% significant level, which make sense as we have indications that the distribution is non-stationary
plot(lrt_result_2)
# Compare the two models using likelihood ratio test: Ho: no significant difference in model fit H1: there is a significant difference in model fit between the two models.
lrt_result <- lr.test(gev_fix, gev_time_varying) # we can almost reject the null hypothesis at 95% significant level, which make sense as we have indications that the distribution is non-stationary
plot(lrt_result) # can't show diagnostic plot for some reason
View(lrt_result)
knitr::opts_chunk$set(echo = TRUE)
# Set initial parameters
initial_inventory <- 500
mean_sales <- 100
std_dev_sales <- 15
reorder_point <- 400
order_quantity <- 300
delivery_time <- 2
# Create vectors to store data
sales <- numeric(52)
deliveries <- numeric(52)
inventory <- numeric(52)
# Initialize variables
current_inventory <- initial_inventory
order_pending <- FALSE
weeks_to_delivery <- 2
# Simulation for 52 weeks
for (week in 1:52) {
# Simulate weekly sales
weekly_sales <- max(0, round(rnorm(1, mean_sales, std_dev_sales)))
# If demand exceeds inventory, limit sales to available stock
if (weekly_sales > current_inventory) {
weekly_sales <- current_inventory
}
# Update inventory
current_inventory <- current_inventory - weekly_sales
# Check if an order is needed
if (current_inventory < reorder_point && !order_pending) {
order_pending <- TRUE
weeks_to_delivery <- delivery_time
} else {
# Check if a delivery has arrived
if (weeks_to_delivery == 0 && order_pending) {
order_pending <- FALSE
current_inventory <- current_inventory + order_quantity
weeks_to_delivery <- -1  # Reset weeks_to_delivery to -1 to indicate that no more weeks need to be counted for this order
} else if (weeks_to_delivery > 0) {
weeks_to_delivery <- weeks_to_delivery - 1
}
}
# Store data for this week
sales[week] <- weekly_sales
deliveries[week] <- ifelse(weeks_to_delivery == 0 && order_pending, order_quantity, 0)
inventory[week] <- current_inventory
}
# Calculate totals
total_sales <- sum(sales)
total_orders_placed <- sum(ifelse(deliveries > 0, 1, 0))
final_inventory <- inventory[52]
# Create a data frame for the annual report
report <- data.frame(Week = 1:52, "Apples Sold" = sales, "Deliveries Received" = deliveries, "Remaining Inventory" = inventory)
# Display summary
cat("Total Apples Sold:", total_sales, "\n")
cat("Total Orders Placed:", total_orders_placed, "\n")
cat("Final Inventory:", final_inventory, "\n")
# Display annual report
print(report)
