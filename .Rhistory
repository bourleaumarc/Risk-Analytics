), ]
# Subset the winter months (November to February)
#winter_night_min <- night_min[format(night_min$date, "%m") %in% c("11", "12", "01", "02"), ]
# Invert night.min as temperatures are negative
winter_night_min$night.min <- -winter_night_min$night.min
# Visualise the data: plot and histogram
p <- ggplot(winter_night_min, aes(x = date, y = night.min)) +
geom_line() +  # This adds the line type plot
labs(x = "Date", y = "Night Min Temperature", title = "Winter Night Min Temperatures") +
theme_minimal()  # Optional: adds a minimal theme
interactive_plot_winter <- ggplotly(p)
interactive_plot_winter
hist(winter_night_min$night.min, breaks = 30, col = "skyblue", xlab = "Date", ylab = "Night Min Temperature", main = "Winter Night Min Temperatures frequency")
# Have more information about the distribution
min(winter_night_min$night.min); mean(winter_night_min$night.min); max(winter_night_min$night.min)
quantile(winter_night_min$night.min, 0.95)
# Choose the threshold using the mrlplot()
mrlplot(winter_night_min$night.min, main="Mean residual")
threshrange.plot(winter_night_min$night.min, r= c(0,6), nint =20)
th_2 <- 3.3
# Visualise the threshold
plot(winter_night_min$night.min, type = 'l')
abline(h=th_2,col=2) # looks good
# Assess the threshold
pot_mle_2 <- fevd(winter_night_min$night.min, method = "MLE", type="GP", threshold=th_2)
plot(pot_mle_2)
rl_mle <- return.level(pot_mle_2, conf = 0.05, return.period= c(2,5,10,20,50,100), do.ci=T) # diagnostic plot looks good and confidence interval become wider the longer the return level, which make sense
# Return level plots with MLE
par(mfcol=c(1,1))
plot(pot_mle_2, type="rl",
main="Return Level Plot for Oberwang w/ MLE",
ylim=c(0,200), pch=16)
loc <- as.numeric(return.level(pot_mle_2, conf = 0.05, return.period=50))
segments(50, 0, 50, loc, col= 'midnightblue',lty=6)
segments(0.01,loc,50, loc, col='midnightblue', lty=6)
# Assess wether extremes occur in a cluster using extremalindex()
extremalindex(winter_night_min$night.min, th_2) # 0.32 so 1/0.32 = 3.125
########################### Declustering ###########################
# We need to create a vector of size night_min that stores the year.
years_part3_2 <- c()
k <- 1
for (i in 1:nrow(winter_night_min)) {
if (is.na(winter_night_min$night.min[i])) {
next
} else {
years_part3_2[k] <- year(winter_night_min$date[i])
k <- k + 1
}
}
years_part3_2 <- years_part3_2-1999
# Use decluster function of extRemes
decl2 <- decluster(winter_night_min$night.min, threshold=th_2, groups=years_part3_2, na.action=na.omit) # vector and groups need to have the same size
decl2 # we have 71 clusters
plot(decl2) # shows in grey the points that are not retained in the selection
# Fit GPD with clustered and declustered data
# Use fevd of the normal and declustered
gpd_raw_2 <- fevd(winter_night_min$night.min, threshold = th_2, type = "GP")
gpd_declustered_2 <- fevd(decl2, threshold = th_2, type = "GP")
par(mfrow = c(2, 2))
plot(gpd_raw_2)
title(main = "GPD fitted to raw data", line = 1, col.main = "red")
plot(gpd_declustered_2)
title(main = "GPD fitted to declustered data", line = 1, col.main = "red")
par(mfrow = c(1, 1))
# Assess the fit: AIC for raw is 38100, AIC for declustered data is 193
# Assuming 'night_min' has a 'date' column in Date format
night_min$year <- as.numeric(format(night_min$date, "%Y"))
night_min$month <- format(night_min$date, "%m")
# Create a new column for the winter season
night_min$winter_season <- ifelse(night_min$month %in% c("01", "02"),
paste(night_min$year - 1, night_min$year, sep="-"),
paste(night_min$year, night_min$year + 1, sep="-"))
# November and December of year t and January and February of year t+1
winter_night_min <- night_min[(night_min$month %in% c("11", "12") &
night_min$year == t) |
(night_min$month %in% c("01", "02") &
night_min$year == t + 1), ]
night_min$year <- as.numeric(format(night_min$date, "%Y"))
night_min$month <- format(night_min$date, "%m")
night_min <- night_min %>%
mutate(
year = as.numeric(format(date, "%Y")),
month = format(date, "%m"),
season_year = ifelse(month %in% c("01", "02"), year - 1, year)
)
# Assuming 'night_min' has a 'date' column in Date format
night_min$year <- as.numeric(format(night_min$date, "%Y"))
night_min$month <- format(night_min$date, "%m")
night_min <- night_min %>%
mutate(
year = as.numeric(format(date, "%Y")),
month = format(date, "%m"),
season_year = ifelse(month %in% c("01", "02"), year - 1, year)
)
# Subset for winter months
winter_night_min <- night_min %>%
filter(
(month %in% c("11", "12") & season_year == year) |
(month %in% c("01", "02") & season_year == year - 1)
)
# Assuming 'night_min' has a 'date' column in Date format
night_min$year <- as.numeric(format(night_min$date, "%Y"))
night_min$month <- format(night_min$date, "%m")
night_min <- night_min %>%
mutate(
year = as.numeric(format(date, "%Y")),
month = format(date, "%m"),
season_year = ifelse(month %in% c("01", "02"), year - 1, year)
)
# Subset for winter months
winter_night_min <- night_min %>%
filter(
(month %in% c("11", "12") & season_year == year) |
(month %in% c("01", "02") & season_year == year - 1)
)
# Subset the winter months (November to February)
#winter_night_min <- night_min[format(night_min$date, "%m") %in% c("11", "12", "01", "02"), ]
# Invert night.min as temperatures are negative
winter_night_min$night.min <- -winter_night_min$night.min
# Visualise the data: plot and histogram
p <- ggplot(winter_night_min, aes(x = date, y = night.min)) +
geom_line() +  # This adds the line type plot
labs(x = "Date", y = "Night Min Temperature", title = "Winter Night Min Temperatures") +
theme_minimal()  # Optional: adds a minimal theme
interactive_plot_winter <- ggplotly(p)
interactive_plot_winter
hist(winter_night_min$night.min, breaks = 30, col = "skyblue", xlab = "Date", ylab = "Night Min Temperature", main = "Winter Night Min Temperatures frequency")
# Have more information about the distribution
min(winter_night_min$night.min); mean(winter_night_min$night.min); max(winter_night_min$night.min)
quantile(winter_night_min$night.min, 0.95)
# Choose the threshold using the mrlplot()
mrlplot(winter_night_min$night.min, main="Mean residual")
threshrange.plot(winter_night_min$night.min, r= c(0,6), nint =20)
th_2 <- 3.3
# Visualise the threshold
plot(winter_night_min$night.min, type = 'l')
abline(h=th_2,col=2) # looks good
# Assess the threshold
pot_mle_2 <- fevd(winter_night_min$night.min, method = "MLE", type="GP", threshold=th_2)
plot(pot_mle_2)
rl_mle <- return.level(pot_mle_2, conf = 0.05, return.period= c(2,5,10,20,50,100), do.ci=T) # diagnostic plot looks good and confidence interval become wider the longer the return level, which make sense
# Return level plots with MLE
par(mfcol=c(1,1))
plot(pot_mle_2, type="rl",
main="Return Level Plot for Oberwang w/ MLE",
ylim=c(0,200), pch=16)
loc <- as.numeric(return.level(pot_mle_2, conf = 0.05, return.period=50))
segments(50, 0, 50, loc, col= 'midnightblue',lty=6)
segments(0.01,loc,50, loc, col='midnightblue', lty=6)
# Assess wether extremes occur in a cluster using extremalindex()
extremalindex(winter_night_min$night.min, th_2) # 0.32 so 1/0.32 = 3.125
########################### Declustering ###########################
# We need to create a vector of size night_min that stores the year.
years_part3_2 <- c()
k <- 1
for (i in 1:nrow(winter_night_min)) {
if (is.na(winter_night_min$night.min[i])) {
next
} else {
years_part3_2[k] <- year(winter_night_min$date[i])
k <- k + 1
}
}
years_part3_2 <- years_part3_2-1999
# Use decluster function of extRemes
decl2 <- decluster(winter_night_min$night.min, threshold=th_2, groups=years_part3_2, na.action=na.omit) # vector and groups need to have the same size
decl2 # we have 71 clusters
plot(decl2) # shows in grey the points that are not retained in the selection
# Fit GPD with clustered and declustered data
# Use fevd of the normal and declustered
gpd_raw_2 <- fevd(winter_night_min$night.min, threshold = th_2, type = "GP")
gpd_declustered_2 <- fevd(decl2, threshold = th_2, type = "GP")
par(mfrow = c(2, 2))
plot(gpd_raw_2)
title(main = "GPD fitted to raw data", line = 1, col.main = "red")
plot(gpd_declustered_2)
title(main = "GPD fitted to declustered data", line = 1, col.main = "red")
par(mfrow = c(1, 1))
# Assess the fit: AIC for raw is 38100, AIC for declustered data is 193
source(here::here("script/setup.R"))
night_max <- read_csv(here::here("data/nightmax.csv"))
night_min <- read_csv(here::here("data/nightmin.csv"))
# Remove rows with missing values
night_max <- na.omit(night_max)
night_min <- na.omit(night_min)
# Subset the data for summer months (June to September)
summer_night_max <- night_max[format(night_max$date,"%m") %in% c("06", "07", "08", "09"), ]
night_min$year <- as.numeric(format(night_min$date, "%Y"))
night_min$month <- format(night_min$date, "%m")
View(night_min)
night_min <- night_min %>%
mutate(
year = as.numeric(format(date, "%Y")),
month = format(date, "%m"),
season_year = ifelse(month %in% c("01", "02"), year - 1, year)
)
winter_night_min <- night_min %>%
filter(
(month %in% c("11", "12") & season_year == year) |
(month %in% c("01", "02") & season_year == year - 1)
)
View(winter_night_min)
winter_night_min$night.min <- -winter_night_min$night.min
p <- ggplot(winter_night_min, aes(x = season_year , y = night.min)) +
geom_line() +  # This adds the line type plot
labs(x = "Date", y = "Night Min Temperature", title = "Winter Night Min Temperatures") +
theme_minimal()  # Optional: adds a minimal theme
interactive_plot_winter <- ggplotly(p)
interactive_plot_winter
winter_night_min <- winter_night_min %>% mutate(month_season = paste(month, season_year, sep = "-"))
winter_night_min <- winter_night_min %>% mutate(day = day(date), full_date = paste(day, month, season_year, sep = "-"))
winter_night_min <- winter_night_min %>% mutate(full_date = as.Date(full_date, format = "%d-%m-%Y"))
p <- ggplot(winter_night_min, aes(x = full_date , y = night.min)) +
geom_line() +  # This adds the line type plot
labs(x = "Date", y = "Night Min Temperature", title = "Winter Night Min Temperatures") +
theme_minimal()  # Optional: adds a minimal theme
interactive_plot_winter <- ggplotly(p)
interactive_plot_winter
hist(winter_night_min$night.min, breaks = 30, col = "skyblue", xlab = "Date", ylab = "Night Min Temperature", main = "Winter Night Min Temperatures frequency")
?hist
mrlplot(winter_night_min$night.min, main="Mean residual")
threshrange.plot(winter_night_min$night.min, r= c(0,6), nint =20)
quantile(winter_night_min$night.min, 0.95)
plot(winter_night_min$night.min, type = 'l')
plot(winter_night_min$night.min, type = 'l')
abline(h=th_2,col=2)
th_2 <- 3.3
plot(winter_night_min$night.min, type = 'l')
abline(h=th_2,col=2)
pot_mle_2 <- fevd(winter_night_min$night.min, method = "MLE", type="GP", threshold=th_2)
plot(pot_mle_2)
rl_mle <- return.level(pot_mle_2, conf = 0.05, return.period= c(2,5,10,20,50,100), do.ci=T) # diagnostic plot looks good and confidence interval become wider the longer the return level, which make sense
# Invert night.min as temperatures are negative
winter_night_min$night.min <- -winter_night_min$night.min
# Visualise the data: plot and histogram
p <- ggplot(winter_night_min, aes(x = full_date , y = night.min)) +
geom_line() +  # This adds the line type plot
labs(x = "Date", y = "Night Min Temperature", title = "Winter Night Min Temperatures") +
theme_minimal()  # Optional: adds a minimal theme
interactive_plot_winter <- ggplotly(p)
interactive_plot_winter
hist(winter_night_min$night.min, breaks = 30, col = "skyblue", xlab = "Frequency", ylab = "Night Min Temperature", main = "Winter Night Min Temperatures frequency")
# Have more information about the distribution
min(winter_night_min$night.min); mean(winter_night_min$night.min); max(winter_night_min$night.min)
quantile(winter_night_min$night.min, 0.95)
# Choose the threshold using the mrlplot()
mrlplot(winter_night_min$night.min, main="Mean residual")
threshrange.plot(winter_night_min$night.min, r= c(0,6), nint =20)
th_2 <- 3.3
# Visualise the threshold
plot(winter_night_min$night.min, type = 'l')
abline(h=th_2,col=2) # looks good
# Assess the threshold
pot_mle_2 <- fevd(winter_night_min$night.min, method = "MLE", type="GP", threshold=th_2)
plot(pot_mle_2)
rl_mle <- return.level(pot_mle_2, conf = 0.05, return.period= c(2,5,10,20,50,100), do.ci=T) # diagnostic plot looks good and confidence interval become wider the longer the return level, which make sense
# Return level plots with MLE
par(mfcol=c(1,1))
plot(pot_mle_2, type="rl",
main="Return Level Plot for Oberwang w/ MLE",
ylim=c(0,200), pch=16)
loc <- as.numeric(return.level(pot_mle_2, conf = 0.05, return.period=50))
segments(50, 0, 50, loc, col= 'midnightblue',lty=6)
segments(0.01,loc,50, loc, col='midnightblue', lty=6)
# Assess wether extremes occur in a cluster using extremalindex()
extremalindex(winter_night_min$night.min, th_2) # 0.32 so 1/0.32 = 3.125
########################### Declustering ###########################
# We need to create a vector of size night_min that stores the year.
years_part3_2 <- c()
k <- 1
for (i in 1:nrow(winter_night_min)) {
if (is.na(winter_night_min$night.min[i])) {
next
} else {
years_part3_2[k] <- year(winter_night_min$date[i])
k <- k + 1
}
}
years_part3_2 <- years_part3_2-1999
# Use decluster function of extRemes
decl2 <- decluster(winter_night_min$night.min, threshold=th_2, groups=years_part3_2, na.action=na.omit) # vector and groups need to have the same size
decl2 # we have 71 clusters
plot(decl2) # shows in grey the points that are not retained in the selection
# Fit GPD with clustered and declustered data
# Use fevd of the normal and declustered
gpd_raw_2 <- fevd(winter_night_min$night.min, threshold = th_2, type = "GP")
gpd_declustered_2 <- fevd(decl2, threshold = th_2, type = "GP")
par(mfrow = c(2, 2))
plot(gpd_raw_2)
title(main = "GPD fitted to raw data", line = 1, col.main = "red")
plot(gpd_declustered_2)
title(main = "GPD fitted to declustered data", line = 1, col.main = "red")
par(mfrow = c(1, 1))
# Assess the fit: AIC for raw is 38100, AIC for declustered data is 193
knitr::opts_chunk$set(echo = TRUE)
source(here::here("script/setup.R"))
knitr::opts_chunk$set(echo = TRUE)
source(here::here("script/setup.R"))
##### Download daily NAO measurements
NAO.daily <-
fread('ftp://ftp.cdc.noaa.gov/Public/gbates/teleconn/nao.reanalysis.t10trunc.1948-present.txt')
NAO.daily <- as.matrix(NAO.daily)
colnames(NAO.daily) <- c("year","month","day","NAO")
##### Download temperature data: be sure to work in the correct directory
months <- c(12,1,2) #keep only winter observations
library(readr)
temp_max_Zermatt <- read_delim("daily_maximum_Zermatt/order_107669_data.txt",
";", escape_double = FALSE, col_types =
cols(time = col_number()),
trim_ws = TRUE, skip = 1)
colnames(temp_max_Zermatt) <- c("station","time","temp")
temp_max_Zermatt           <- temp_max_Zermatt[-1,]
temp_max_Zermatt[,2]       <- as.Date(apply(temp_max_Zermatt[,2],1,as.character),
"%Y%m%d")
temp_max_Montana <- read_delim("daily_maximum_Montana/order_107668_data.txt", ";", escape_double = FALSE, col_types = cols(time = col_number()), trim_ws = TRUE, skip = 1)
colnames(temp_max_Montana) <- c("station","time","temp")
temp_max_Montana           <- temp_max_Montana[-1,]
temp_max_Montana[,2]       <- as.Date(apply(temp_max_Montana[,2],1,as.character),
"%Y%m%d")
###match the dates of the two time series
temp_max_Montana           <- temp_max_Montana[match(as.matrix(temp_max_Zermatt[,2]),
as.matrix(temp_max_Montana[,2])),]
temp_max_Montana           <- as.matrix(temp_max_Montana)
colnames(temp_max_Montana) <- c("station","time","temp")
temp_max_Zermatt           <- as.matrix(temp_max_Zermatt)
colnames(temp_max_Zermatt) <- c("station","time","temp")
###keep only winter dates
library(lubridate)
temp_max_Montana <- temp_max_Montana[which(month(as.POSIXlt(temp_max_Montana[,"time"],
format="%Y-%m-%d")) %in% months),]
temp_max_Zermatt <- temp_max_Zermatt[which(month(as.POSIXlt(temp_max_Zermatt[,"time"],
format="%Y-%m-%d")) %in% months),]
Date       <- function( length = 0 ){
newDate = numeric( length )
class(newDate) = "Date"
return(newDate)
}
season_day                   <- yday(as.Date(temp_max_Montana[,2]))
season_day[season_day < 61]  <- season_day[season_day < 61] + 31
season_day[season_day > 334] <- season_day[season_day > 334]- 334
NAO.date <- Date(nrow(NAO.daily))
for(i in 1:nrow(NAO.daily)){
NAO.date[i] <- as.Date(paste(as.character(NAO.daily[i,1]),"-",as.character(NAO.daily[i,2]),
"-",as.character(NAO.daily[i,3]),sep=""),format="%Y-%m-%d")
}
nao  <- NAO.daily[intersect(as.Date(temp_max_Montana[,2]),as.Date(NAO.date)),4]
#Montana
x_Montana          <- data.frame("time"=temp_max_Montana[,2],
"nao"=nao,
"d"=season_day,
"temp"=temp_max_Montana[,3])
as.numeric.factor  <- function(x) {as.numeric(levels(x))[x]}
x_Montana[,"temp"] <- as.numeric(x_Montana[,"temp"])
x_Montana[,"time"] <- as.numeric(year(as.POSIXlt(x_Montana[,"time"], format="%Y-%m-%d")))
x_Montana[,"time"] <- (x_Montana[,"time"]-min(x_Montana[,"time"]))/(max(x_Montana[,"time"])-
min(x_Montana[,"time"]))
#Zermatt
x_Zermatt          <- data.frame("time"=temp_max_Zermatt[,2],
"nao"=nao,
"d"=season_day,
"temp"=temp_max_Zermatt[,3])
as.numeric.factor  <- function(x) {as.numeric(levels(x))[x]}
x_Zermatt[,"temp"] <- as.numeric(x_Zermatt[,"temp"])
x_Zermatt[,"time"] <- as.numeric(year(as.POSIXlt(x_Zermatt[,"time"], format="%Y-%m-%d")))
x_Zermatt[,"time"] <- (x_Zermatt[,"time"]-min(x_Zermatt[,"time"]))/(max(x_Zermatt[,"time"])-
min(x_Zermatt[,"time"]))
Z <- data.frame("Montana"=x_Montana[,"temp"] , "Zermatt"=x_Zermatt[,"temp"], "NAO"=x_Zermatt[,"nao"])
View(x_Montana)
View(Z)
View(x_Zermatt)
# Scatterplot of Zermatt values against Montana values
plot(Z$Montana, Z$Zermatt, xlab = "Montana Temperature", ylab = "Zermatt Temperature",
main = "Zermatt vs Montana Temperatures")
abline(lm(Z$Zermatt ~ Z$Montana), col = "red") # Add a linear regression line
# Scatterplot of Montana values against NAO values
plot(Z$Montana, Z$NAO, xlab = "Montana Temperature", ylab = "NAO Index",
main = "Montana Temperature vs NAO Index")
abline(lm(Z$NAO ~ Z$Montana), col = "blue") # Add a linear regression line
View(x_Montana)
# Scatterplot of Zermatt values against Montana values
plot(Z$Montana, Z$Zermatt, xlab = "Montana Temperature", ylab = "Zermatt Temperature",
main = "Zermatt vs Montana Temperatures")
abline(lm(Z$Zermatt ~ Z$Montana), col = "red") # Add a linear regression line
legend("topright", # places the legend in the top right corner of the plot
legend = "Fitted Regression Line",
col = "red",
lty = 1, # type of line, 1 is for solid
cex = 0.8) # controls the size of the text in the legend
night_max <- read_csv(here::here("data/practical_2/nightmax.csv"))
night_min <- read_csv(here::here("data/practical_2/nightmin.csv"))
temp_max_Montana <- read_delim(here::here("data/practical_3/daily_maximum_Montana/order_107668_data.txt"), ";", escape_double = FALSE, col_types = cols(time = col_number()), trim_ws = TRUE, skip = 1)
source(here::here("script/setup.R"))
knitr::opts_chunk$set(echo = TRUE)
##### Download daily NAO measurements
NAO.daily <-
fread('ftp://ftp.cdc.noaa.gov/Public/gbates/teleconn/nao.reanalysis.t10trunc.1948-present.txt')
NAO.daily <- as.matrix(NAO.daily)
colnames(NAO.daily) <- c("year","month","day","NAO")
##### Download temperature data: be sure to work in the correct directory
months <- c(12,1,2) #keep only winter observations
temp_max_Zermatt <- read_delim(here::here("daily_maximum_Zermatt/order_107669_data.txt"),
";", escape_double = FALSE, col_types =
cols(time = col_number()),
trim_ws = TRUE, skip = 1)
##### Download daily NAO measurements
NAO.daily <-
fread('ftp://ftp.cdc.noaa.gov/Public/gbates/teleconn/nao.reanalysis.t10trunc.1948-present.txt')
NAO.daily <- as.matrix(NAO.daily)
colnames(NAO.daily) <- c("year","month","day","NAO")
##### Download temperature data: be sure to work in the correct directory
months <- c(12,1,2) #keep only winter observations
temp_max_Zermatt <- read_delim(here::here("data/practical_3/daily_maximum_Zermatt/order_107669_data.txt"),
";", escape_double = FALSE, col_types =
cols(time = col_number()),
trim_ws = TRUE, skip = 1)
colnames(temp_max_Zermatt) <- c("station","time","temp")
temp_max_Zermatt           <- temp_max_Zermatt[-1,]
temp_max_Zermatt[,2]       <- as.Date(apply(temp_max_Zermatt[,2],1,as.character),
"%Y%m%d")
temp_max_Montana <- read_delim(here::here("data/practical_3/daily_maximum_Montana/order_107668_data.txt"), ";", escape_double = FALSE, col_types = cols(time = col_number()), trim_ws = TRUE, skip = 1)
colnames(temp_max_Montana) <- c("station","time","temp")
temp_max_Montana           <- temp_max_Montana[-1,]
temp_max_Montana[,2]       <- as.Date(apply(temp_max_Montana[,2],1,as.character),
"%Y%m%d")
###match the dates of the two time series
temp_max_Montana           <- temp_max_Montana[match(as.matrix(temp_max_Zermatt[,2]),
as.matrix(temp_max_Montana[,2])),]
temp_max_Montana           <- as.matrix(temp_max_Montana)
colnames(temp_max_Montana) <- c("station","time","temp")
temp_max_Zermatt           <- as.matrix(temp_max_Zermatt)
colnames(temp_max_Zermatt) <- c("station","time","temp")
###keep only winter dates
temp_max_Montana <- temp_max_Montana[which(month(as.POSIXlt(temp_max_Montana[,"time"],
format="%Y-%m-%d")) %in% months),]
temp_max_Zermatt <- temp_max_Zermatt[which(month(as.POSIXlt(temp_max_Zermatt[,"time"],
format="%Y-%m-%d")) %in% months),]
Date       <- function( length = 0 ){
newDate = numeric( length )
class(newDate) = "Date"
return(newDate)
}
season_day                   <- yday(as.Date(temp_max_Montana[,2]))
season_day[season_day < 61]  <- season_day[season_day < 61] + 31
season_day[season_day > 334] <- season_day[season_day > 334]- 334
NAO.date <- Date(nrow(NAO.daily))
for(i in 1:nrow(NAO.daily)){
NAO.date[i] <- as.Date(paste(as.character(NAO.daily[i,1]),"-",as.character(NAO.daily[i,2]),
"-",as.character(NAO.daily[i,3]),sep=""),format="%Y-%m-%d")
}
nao  <- NAO.daily[intersect(as.Date(temp_max_Montana[,2]),as.Date(NAO.date)),4]
#Montana
x_Montana          <- data.frame("time"=temp_max_Montana[,2],
"nao"=nao,
"d"=season_day,
"temp"=temp_max_Montana[,3])
as.numeric.factor  <- function(x) {as.numeric(levels(x))[x]}
x_Montana[,"temp"] <- as.numeric(x_Montana[,"temp"])
x_Montana[,"time"] <- as.numeric(year(as.POSIXlt(x_Montana[,"time"], format="%Y-%m-%d")))
x_Montana[,"time"] <- (x_Montana[,"time"]-min(x_Montana[,"time"]))/(max(x_Montana[,"time"])-
min(x_Montana[,"time"]))
#Zermatt
x_Zermatt          <- data.frame("time"=temp_max_Zermatt[,2],
"nao"=nao,
"d"=season_day,
"temp"=temp_max_Zermatt[,3])
as.numeric.factor  <- function(x) {as.numeric(levels(x))[x]}
x_Zermatt[,"temp"] <- as.numeric(x_Zermatt[,"temp"])
x_Zermatt[,"time"] <- as.numeric(year(as.POSIXlt(x_Zermatt[,"time"], format="%Y-%m-%d")))
x_Zermatt[,"time"] <- (x_Zermatt[,"time"]-min(x_Zermatt[,"time"]))/(max(x_Zermatt[,"time"])-
min(x_Zermatt[,"time"]))
Z <- data.frame("Montana"=x_Montana[,"temp"] , "Zermatt"=x_Zermatt[,"temp"], "NAO"=x_Zermatt[,"nao"])
# Scatterplot of Zermatt values against Montana values
plot(Z$Montana, Z$Zermatt, xlab = "Montana Temperature", ylab = "Zermatt Temperature",
main = "Zermatt vs Montana Temperatures")
abline(lm(Z$Zermatt ~ Z$Montana), col = "red")
legend("topright",
legend = "Fitted Regression Line",
col = "red",
lty = 1,
cex = 0.8)
# Scatterplot of Montana values against NAO values
plot(Z$Montana, Z$NAO, xlab = "Montana Temperature", ylab = "NAO Index",
main = "Montana Temperature vs NAO Index")
abline(lm(Z$NAO ~ Z$Montana), col = "red") # Add a linear regression line
legend("topright",
legend = "Fitted Regression Line",
col = "red",
lty = 1,
cex = 0.8)
cor_Zermatt_Montana <- cor(Z$Zermatt, Z$Montana)
cat("Correlation between Zermatt and Montana Temperatures:", cor_Zermatt_Montana, "\n")
# Correlation between Montana Temperatures and NAO Index
cor_Montana_NAO <- cor(Z$Montana, Z$NAO)
cat("Correlation between Montana Temperatures and NAO Index:", cor_Montana_NAO, "\n")
library(evd)
# Create a data frame for Zermatt vs Montana Temperatures
data_Zermatt_Montana <- data.frame(Zermatt = Z$Zermatt, Montana = Z$Montana)
# Chi Plot - Zermatt vs Montana Temperatures
chiplot(data_Zermatt_Montana, main1 = "Chi Plot - Zermatt vs Montana Temperatures")
# Create a data frame for Montana Temperatures vs NAO Index
data_Montana_NAO <- data.frame(Montana = Z$Montana, NAO = Z$NAO)
# Chi Plot - Montana Temperatures vs NAO Index
chiplot(data_Montana_NAO, main1 = "Chi Plot - Montana Temperatures vs NAO Index")
# Assuming your data is stored in a data frame called Z
library(evd)
# Pair 1: Zermatt vs. Montana
pair_1_diff <- Z$Zermatt - Z$Montana
chiplot(cbind(pair_1_diff, pair_1_diff^2))  # Only include differences and squared differences
# Pair 2: Montana vs. NAO
pair_2_diff <- Z$Montana - Z$NAO
chiplot(cbind(pair_2_diff, pair_2_diff^2))  # Only include differences and squared differences
load(here::here("data/practical_2/niveau.Rdata"))
