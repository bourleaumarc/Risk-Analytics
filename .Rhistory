library(lmtest)
# Function to fit a time-varying GEV model for the specified parameter
fit_time_varying_gev <- function(parameter) {
formula1 <- as.formula(paste(" ~ year + ", parameter))
return(fevd(list_max_sea_levels, type = "GEV", time.units = "years"))
}
# Initialize variables to keep track of the best model
best_gev_model <- gev_fix  # Start with the constant parameter model
best_LRT_statistic <- 0   # Initialize with a low value
# Fit time-varying models for each parameter (location, scale, and shape)
parameters_to_test <- c("location", "scale", "shape")
for (param in parameters_to_test) {
# Fit a time-varying GEV model for the parameter
gev_time_varying_param <- fit_time_varying_gev(param)
# Perform LRT between the constant and time-varying models
LRT_result <- lr.test(gev_fix, gev_time_varying_param)
# Compare the LRT statistic with the best so far
if (LRT_result$statistic > best_LRT_statistic) {
best_gev_model <- gev_time_varying_param
best_LRT_statistic <- LRT_result$statistic
}
}
# Print the best model's LRT result
cat("Best Model LRT Result:\n")
print(LRT_result)
# Generate diagnostic plots for the best model
plot(best_gev_model)
# Load required libraries
library(extRemes)
library(lmtest)
# Function to fit a time-varying GEV model for the specified parameter
fit_time_varying_gev <- function(parameter) {
formula1 <- as.formula(paste(" ~ year + ", parameter))
return(fevd(list_max_sea_levels, type = "GEV", time.units = "years", formula1))
}
# Initialize variables to keep track of the best model
best_gev_model <- gev_fix  # Start with the constant parameter model
best_LRT_statistic <- 0   # Initialize with a low value
# Fit time-varying models for each parameter (location, scale, and shape)
parameters_to_test <- c("location", "scale", "shape")
for (param in parameters_to_test) {
# Fit a time-varying GEV model for the parameter
gev_time_varying_param <- fit_time_varying_gev(param)
# Perform LRT between the constant and time-varying models
LRT_result <- lr.test(gev_fix, gev_time_varying_param)
# Compare the LRT statistic with the best so far
if (LRT_result$statistic > best_LRT_statistic) {
best_gev_model <- gev_time_varying_param
best_LRT_statistic <- LRT_result$statistic
}
}
# Load required libraries
library(extRemes)
library(lmtest)
# Function to fit a time-varying GEV model for the specified parameter
fit_time_varying_gev <- function(parameter) {
formula1 <- as.formula(paste(" ~ years + ", parameter))
return(fevd(list_max_sea_levels, type = "GEV", time.units = "years", formula1))
}
# Initialize variables to keep track of the best model
best_gev_model <- gev_fix  # Start with the constant parameter model
best_LRT_statistic <- 0   # Initialize with a low value
# Fit time-varying models for each parameter (location, scale, and shape)
parameters_to_test <- c("location", "scale", "shape")
for (param in parameters_to_test) {
# Fit a time-varying GEV model for the parameter
gev_time_varying_param <- fit_time_varying_gev(param)
# Perform LRT between the constant and time-varying models
LRT_result <- lr.test(gev_fix, gev_time_varying_param)
# Compare the LRT statistic with the best so far
if (LRT_result$statistic > best_LRT_statistic) {
best_gev_model <- gev_time_varying_param
best_LRT_statistic <- LRT_result$statistic
}
}
# Load required libraries
library(extRemes)
library(lmtest)
# Function to fit a time-varying GEV model for the specified parameter
fit_time_varying_gev <- function(parameter) {
formula1 <- as.formula(paste(" ~ year + ", parameter))
return(fevd(list_max_sea_levels, type = "GEV", time.units = "years"))
}
# Initialize variables to keep track of the best model
best_gev_model <- gev_fix  # Start with the constant parameter model
best_LRT_statistic <- 0   # Initialize with a low value
# Fit time-varying models for each parameter (location, scale, and shape)
parameters_to_test <- c("location", "scale", "shape")
for (param in parameters_to_test) {
# Fit a time-varying GEV model for the parameter
gev_time_varying_param <- fit_time_varying_gev(param)
# Perform LRT between the constant and time-varying models
LRT_result <- lr.test(gev_fix, gev_time_varying_param)
# Compare the LRT statistic with the best so far
if (LRT_result$statistic > best_LRT_statistic) {
best_gev_model <- gev_time_varying_param
best_LRT_statistic <- LRT_result$statistic
}
}
# Print the best model's LRT result
cat("Best Model LRT Result:\n")
print(LRT_result)
# Generate diagnostic plots for the best model
plot(best_gev_model)
# Load required libraries
library(extRemes)
library(lmtest)
# Function to fit a time-varying GEV model for the specified parameter
fit_time_varying_gev <- function(parameter) {
formula1 <- as.formula(paste(" sea-level ~ year + ", parameter))
return(fevd(list_max_sea_levels, type = "GEV", time.units = "years"))
}
# Initialize variables to keep track of the best model
best_gev_model <- gev_fix  # Start with the constant parameter model
best_LRT_statistic <- 0   # Initialize with a low value
# Fit time-varying models for each parameter (location, scale, and shape)
parameters_to_test <- c("location", "scale", "shape")
for (param in parameters_to_test) {
# Fit a time-varying GEV model for the parameter
gev_time_varying_param <- fit_time_varying_gev(param)
# Perform LRT between the constant and time-varying models
LRT_result <- lr.test(gev_fix, gev_time_varying_param)
# Compare the LRT statistic with the best so far
if (LRT_result$statistic > best_LRT_statistic) {
best_gev_model <- gev_time_varying_param
best_LRT_statistic <- LRT_result$statistic
}
}
# Print the best model's LRT result
cat("Best Model LRT Result:\n")
print(LRT_result)
# Generate diagnostic plots for the best model
plot(best_gev_model)
# Load required libraries
library(extRemes)
library(lmtest)
# Function to fit a time-varying GEV model for the specified parameter
fit_time_varying_gev <- function(parameter) {
formula_text <- paste("sealevel ~ year + ", parameter)
formula <- as.formula(formula_text)
return(fevd(formula, data = yearly_data, type = "GEV", time.units = "years"))
}
# Initialize variables to keep track of the best model
best_gev_model <- gev_fix  # Start with the constant parameter model
best_LRT_statistic <- 0   # Initialize with a low value
# Fit time-varying models for each parameter (location, scale, and shape)
parameters_to_test <- c("location", "scale", "shape")
for (param in parameters_to_test) {
# Fit a time-varying GEV model for the parameter
gev_time_varying_param <- fit_time_varying_gev(param)
# Perform LRT between the constant and time-varying models
LRT_result <- lr.test(gev_fix, gev_time_varying_param)
# Compare the LRT statistic with the best so far
if (LRT_result$statistic > best_LRT_statistic) {
best_gev_model <- gev_time_varying_param
best_LRT_statistic <- LRT_result$statistic
}
}
# Load required libraries
library(extRemes)
# Extract historical yearly maximum sea level values
list_max_sea_levels <- unlist(venice_max$max_sea_level)
# Create a data frame with time-varying location parameter
yearly_data <- data.frame(
year = 2010:2022,  # Adjust the range as per your data
sealevel = list_max_sea_levels
)
# Load required libraries
library(extRemes)
# Extract historical yearly maximum sea level values
list_max_sea_levels <- unlist(venice_max$max_sea_level)
# Fit a GEV model with constant parameters
gev_fix <- fevd(list_max_sea_levels, type = "GEV", time.units = "years")
# Function to fit a time-varying GEV model for the specified parameter
fit_time_varying_gev <- function(parameter) {
formula_text <- paste("sealevel ~ 1", parameter, "+ year")
formula <- as.formula(formula_text)
return(fevd(formula, data = yearly_data, type = "GEV", time.units = "years"))
}
# Initialize variables to keep track of the best model
best_gev_model <- gev_fix  # Start with the constant parameter model
best_LRT_statistic <- 0   # Initialize with a low value
# Fit time-varying models for each parameter (scale and shape)
parameters_to_test <- c("~ scale", "~ shape")
for (param in parameters_to_test) {
# Fit a time-varying GEV model for the parameter
gev_time_varying_param <- fit_time_varying_gev(param)
# Perform LRT between the constant and time-varying models
LRT_result <- lrtest(gev_fix, gev_time_varying_param)
# Compare the LRT statistic with the best so far
if (LRT_result$statistic > best_LRT_statistic) {
best_gev_model <- gev_time_varying_param
best_LRT_statistic <- LRT_result$statistic
}
}
# Load required libraries
library(extRemes)
# Extract historical yearly maximum sea level values
list_max_sea_levels <- unlist(venice_max$max_sea_level)
# Fit a GEV model with constant parameters
gev_fix <- fevd(list_max_sea_levels, type = "GEV", time.units = "years")
# Function to fit a time-varying GEV model for the specified parameter
fit_time_varying_gev <- function(parameter) {
formula_text <- paste("sealevel ~ 1", parameter, "+ year")
formula <- as.formula(formula_text)
return(fevd(formula, data = venice90, type = "GEV", time.units = "years"))
}
# Initialize variables to keep track of the best model
best_gev_model <- gev_fix  # Start with the constant parameter model
best_LRT_statistic <- 0   # Initialize with a low value
# Fit time-varying models for each parameter (scale and shape)
parameters_to_test <- c("~ scale", "~ shape")
for (param in parameters_to_test) {
# Fit a time-varying GEV model for the parameter
gev_time_varying_param <- fit_time_varying_gev(param)
# Perform LRT between the constant and time-varying models
LRT_result <- lrtest(gev_fix, gev_time_varying_param)
# Compare the LRT statistic with the best so far
if (LRT_result$statistic > best_LRT_statistic) {
best_gev_model <- gev_time_varying_param
best_LRT_statistic <- LRT_result$statistic
}
}
# Load required libraries
library(extRemes)
# Extract historical yearly maximum sea level values
list_max_sea_levels <- unlist(venice_max$max_sea_level)
# Fit a GEV model with constant parameters
gev_fix <- fevd(list_max_sea_levels, type = "GEV", time.units = "years")
# Function to fit a time-varying GEV model for the specified parameter
fit_time_varying_gev <- function(parameter) {
formula_text <- paste("sealevel ~ 1", parameter, "+ year")
formula <- as.formula(formula_text)
return(fevd(formula, data = venice_max, type = "GEV", time.units = "years"))
}
# Initialize variables to keep track of the best model
best_gev_model <- gev_fix  # Start with the constant parameter model
best_LRT_statistic <- 0   # Initialize with a low value
# Fit time-varying models for each parameter (scale and shape)
parameters_to_test <- c("~ scale", "~ shape")
for (param in parameters_to_test) {
# Fit a time-varying GEV model for the parameter
gev_time_varying_param <- fit_time_varying_gev(param)
# Perform LRT between the constant and time-varying models
LRT_result <- lrtest(gev_fix, gev_time_varying_param)
# Compare the LRT statistic with the best so far
if (LRT_result$statistic > best_LRT_statistic) {
best_gev_model <- gev_time_varying_param
best_LRT_statistic <- LRT_result$statistic
}
}
# Load required libraries
library(extRemes)
# Extract historical yearly maximum sea level values
list_max_sea_levels <- unlist(venice_max$max_sea_level)
# Fit a GEV model with constant parameters
gev_fix <- fevd(list_max_sea_levels, type = "GEV", time.units = "years")
# Function to fit a time-varying GEV model for the specified parameter
fit_time_varying_gev <- function(parameter) {
formula_text <- paste("sealevel ~ 1", parameter, "+ year")
formula <- as.formula(formula_text)
return(fevd(formula, data = list_max_sea_levels, type = "GEV", time.units = "years"))
}
# Initialize variables to keep track of the best model
best_gev_model <- gev_fix  # Start with the constant parameter model
best_LRT_statistic <- 0   # Initialize with a low value
# Fit time-varying models for each parameter (scale and shape)
parameters_to_test <- c("~ scale", "~ shape")
for (param in parameters_to_test) {
# Fit a time-varying GEV model for the parameter
gev_time_varying_param <- fit_time_varying_gev(param)
# Perform LRT between the constant and time-varying models
LRT_result <- lrtest(gev_fix, gev_time_varying_param)
# Compare the LRT statistic with the best so far
if (LRT_result$statistic > best_LRT_statistic) {
best_gev_model <- gev_time_varying_param
best_LRT_statistic <- LRT_result$statistic
}
}
# Load required libraries
library(extRemes)
# Extract historical yearly maximum sea level values
list_max_sea_levels <- unlist(venice_max$max_sea_level)
yearly_data <- data.frame(
year = 2010:2022,  # Adjust the range as per your data
sealevel = list_max_sea_levels
)
# Load required libraries
library(extRemes)
# Extract historical yearly maximum sea level values
list_max_sea_levels <- unlist(venice_max$max_sea_level)
yearly_data <- data.frame(
year = 2010:2022,  # Adjust the range as per your data
sealevel = venice90
)
# Fit a GEV model with constant parameters
gev_fix <- fevd(list_max_sea_levels, type = "GEV", time.units = "years")
# Function to fit a time-varying GEV model for the specified parameter
fit_time_varying_gev <- function(parameter) {
formula_text <- paste("sealevel ~ 1", parameter, "+ year")
formula <- as.formula(formula_text)
return(fevd(formula, data = yearly_data, type = "GEV", time.units = "years"))
}
# Initialize variables to keep track of the best model
best_gev_model <- gev_fix  # Start with the constant parameter model
best_LRT_statistic <- 0   # Initialize with a low value
# Fit time-varying models for each parameter (scale and shape)
parameters_to_test <- c("~ scale", "~ shape")
for (param in parameters_to_test) {
# Fit a time-varying GEV model for the parameter
gev_time_varying_param <- fit_time_varying_gev(param)
# Perform LRT between the constant and time-varying models
LRT_result <- lrtest(gev_fix, gev_time_varying_param)
# Compare the LRT statistic with the best so far
if (LRT_result$statistic > best_LRT_statistic) {
best_gev_model <- gev_time_varying_param
best_LRT_statistic <- LRT_result$statistic
}
}
# Load required libraries
library(extRemes)
library(lmtest)
# Extract historical yearly maximum sea level values for the period 2010-2022
list_max_sea_levels <- venice90$sealevel[venice90$year >= 2010]
# Create a data frame with the yearly maximum sea level data
yearly_data <- data.frame(
year = 2010:2022,  # Define the years of interest (2010 to 2022)
sealevel = list_max_sea_levels
)
# Load required libraries
library(extRemes)
library(lmtest)
# Extract historical yearly maximum sea level values for the period 2010-2022
list_max_sea_levels <- venice90$sealevel[venice90$year >= 2010]
# Fit a GEV model with constant parameters for comparison
gev_fix <- fevd(sealevel ~ 1, data = max_real, type = "GEV", time.units = "years")
# Load required libraries
library(extRemes)
library(lmtest)
# Extract historical yearly maximum sea level values for the period 2010-2022
list_max_sea_levels <- venice90$sealevel[venice90$year >= 2010]
# Fit a GEV model with constant parameters for comparison
gev_fix <- fevd( max_sea_levels~ 1, data = max_real, type = "GEV", time.units = "years")
# Fit a GEV model with time-varying shape parameters
gev_time_varying_shape <- fevd(list_max_sea_levels, type = "GEV", time.units = "years", shape.fun = ~year)
list_max_sea_levels
knitr::opts_chunk$set(echo = TRUE)
library(ismev)
library(VGAM)
library(tidyverse)
library(plotly)
library(plotrix)
library(scales)
#QUESTION A
#Read the Data
venice <- venice90
venice_max <- venice %>%
group_by(year) %>%
summarise(max_sea_level = max(sealevel))
head(venice_max)
plot_ly(venice_max, x = ~year, y = ~max_sea_level, type = 'scatter', mode = 'markers', name = 'Max Value') %>% layout(title = "Maximum Value per year", xaxis = list(title="Year"), yaxis = list(title="Maximum Value"))  %>% add_segments(x = 1940, xend = 2009, y = 140, yend = 140, line = list(color = 'red', width = 2))
#QUESTION B
# making predictions with linear models (remainder)
mod1 <- lm(max_sea_level ~ year, data = venice_max)
summary(mod1)
# making predictions for 5 years
mod1_predict <- predict.lm(mod1,newdata=data.frame("year"=c(2010:2022)),se=T, interval = "confidence", level = 0.95)
mod1_predict
#QUESTION C
#Add the model in a data frame
venice_max_predict <- data.frame(
PredictedValues = mod1_predict
) %>%
mutate(year = c(2010:2022))
venice_max_predict
#Plot the confidence intervals
plotCI(x = venice_max_predict$year,
y = venice_max_predict$PredictedValues.fit.fit,
li = venice_max_predict$PredictedValues.fit.lwr,
ui = venice_max_predict$PredictedValues.fit.upr)
#Create a new dataframe for the extreme values of 2010 - 2022
max_real <- data.frame(year = c(2012, 2012, 2013, 2018, 2019, 2019, 2019, 2022), max_sea_level = c(143, 149, 143, 156, 187, 144, 154, 204))
ggplot() +
geom_ribbon(data = venice_max_predict, aes(x = year, ymin = PredictedValues.fit.lwr, ymax = PredictedValues.fit.upr), fill = "blue", alpha = 0.3) +
geom_point(data = max_real, aes(x = year, y = max_sea_level, color = "Observed", colour = "red"), alpha = 0.5) +
geom_point(data = venice_max_predict, aes(x = year, y = PredictedValues.fit.fit, color = "Predicted"), shape = 1) +
labs(title = "Real extreme values from 2010 to 2022 versus predicted values' confidence intervals", x = "Year", y = "Sea Level") +
scale_x_continuous(breaks = unique(c(venice_max_predict$year, max_real$year))) +
scale_color_manual(name = "Data Type", values = c("Observed" = "red", "Predicted" = "black"))
library(extRemes)
list_max_sea_levels <- unlist(venice_max$max_sea_level)
gev_fix <- fevd(list_max_sea_levels, type = "GEV", time.units= "years")
plot(gev_fix) ; gev_fix$results$par
# Fit a GEV model with time-varying location parameters
gev_time_varying <- fevd(list_max_sea_levels, type = "GEV", time.units = "years", location.fun = ~year)
plot(gev_time_varying) ; gev_time_varying$results$par
#compare models with LRT
lrtresults <- lr.test(gev_time_varying, gev_fix)
print(lrtresults)
list_max_sea_levels
# Fit a GEV model with time-varying shape parameters
gev_time_varying_shape <- fevd(list_max_sea_levels, type = "GEV", time.units = "years", shape.fun = ~year)
# Plot the diagnostic plots for the time-varying shape model
plot(gev_time_varying_shape)
# View the parameter estimates for the time-varying shape model
gev_time_varying_shape$results$par
# Compare the model with time-varying scale and shape to the constant parameter model using LRT
lrt_result_scale_shape <- lrTest(gev_time_varying_scale_shape, gev_fix)
# Compare the model with time-varying scale and shape to the constant parameter model using LRT
lrt_result_scale_shape <- lr.test(gev_time_varying_scale_shape, gev_fix)
# Fit a GEV model with time-varying scale and shape parameters
gev_time_varying_scale_shape <- fevd(list_max_sea_levels, type = "GEV", time.units = "years", scale.fun = ~year, shape.fun = ~year)
# Plot the diagnostic plots for the time-varying scale and shape model
plot(gev_time_varying_scale_shape)
# Compare the model with time-varying scale and shape to the constant parameter model using LRT
lrt_result_scale_shape <- lr.test(gev_time_varying_scale_shape, gev_fix)
# Compare the model with time-varying scale and shape to the constant parameter model using LRT
lrt_result_scale_shape <- lr.test(gev_time_varying_scale_shape, gev_fix)
# Compare the model with time-varying scale and shape to the constant parameter model using LRT
lrt_result_scale_shape <- lr.test(gev_time_varying_scale_shape, gev_fix)
# View the LRT result
print(lrt_result_scale_shape)
# Determine the significance level (e.g., 0.05)
significance_level <- 0.05
# Compare the p-value to the significance level
if (lrt_result_scale_shape$p.value < significance_level) {
cat("The model with time-varying scale and shape parameters is preferred.\n")
} else {
cat("The constant parameter model is preferred.\n")
}
# Assuming you have the fitted GEV model (constant parameter) named 'gev_fix'
# Create a sequence of years from 2010 to 2022
years_to_predict <- 2010:2022
# Predict the 13-year return levels for each year
return_levels <- rep(NA, length(years_to_predict))
for (i in 1:length(years_to_predict)) {
# Predict the return level for the current year
current_year <- years_to_predict[i]
prediction_data <- data.frame(year = current_year)
return_levels[i] <- predict(gev_fix, newdata = prediction_data, type = "return", return.period = 13)
}
knitr::opts_chunk$set(echo = TRUE)
library(ismev)
library(VGAM)
library(tidyverse)
library(plotly)
library(plotrix)
library(scales)
#QUESTION A
#Read the Data
venice <- venice90
venice_max <- venice %>%
group_by(year) %>%
summarise(max_sea_level = max(sealevel))
head(venice_max)
plot_ly(venice_max, x = ~year, y = ~max_sea_level, type = 'scatter', mode = 'markers', name = 'Max Value') %>% layout(title = "Maximum Value per year", xaxis = list(title="Year"), yaxis = list(title="Maximum Value"))  %>% add_segments(x = 1940, xend = 2009, y = 140, yend = 140, line = list(color = 'red', width = 2))
#QUESTION B
# making predictions with linear models (remainder)
mod1 <- lm(max_sea_level ~ year, data = venice_max)
summary(mod1)
# making predictions for 5 years
mod1_predict <- predict.lm(mod1,newdata=data.frame("year"=c(2010:2022)),se=T, interval = "confidence", level = 0.95)
mod1_predict
#QUESTION C
#Add the model in a data frame
venice_max_predict <- data.frame(
PredictedValues = mod1_predict
) %>%
mutate(year = c(2010:2022))
venice_max_predict
#Plot the confidence intervals
plotCI(x = venice_max_predict$year,
y = venice_max_predict$PredictedValues.fit.fit,
li = venice_max_predict$PredictedValues.fit.lwr,
ui = venice_max_predict$PredictedValues.fit.upr)
#Create a new dataframe for the extreme values of 2010 - 2022
max_real <- data.frame(year = c(2012, 2012, 2013, 2018, 2019, 2019, 2019, 2022), max_sea_level = c(143, 149, 143, 156, 187, 144, 154, 204))
ggplot() +
geom_ribbon(data = venice_max_predict, aes(x = year, ymin = PredictedValues.fit.lwr, ymax = PredictedValues.fit.upr), fill = "blue", alpha = 0.3) +
geom_point(data = max_real, aes(x = year, y = max_sea_level, color = "Observed", colour = "red"), alpha = 0.5) +
geom_point(data = venice_max_predict, aes(x = year, y = PredictedValues.fit.fit, color = "Predicted"), shape = 1) +
labs(title = "Real extreme values from 2010 to 2022 versus predicted values' confidence intervals", x = "Year", y = "Sea Level") +
scale_x_continuous(breaks = unique(c(venice_max_predict$year, max_real$year))) +
scale_color_manual(name = "Data Type", values = c("Observed" = "red", "Predicted" = "black"))
library(extRemes)
list_max_sea_levels <- unlist(venice_max$max_sea_level)
gev_fix <- fevd(list_max_sea_levels, type = "GEV", time.units= "years")
plot(gev_fix) ; gev_fix$results$par
# Fit a GEV model with time-varying location parameters
gev_time_varying <- fevd(list_max_sea_levels, type = "GEV", time.units = "years", location.fun = ~year)
plot(gev_time_varying) ; gev_time_varying$results$par
#compare models with LRT
lrtresults <- lr.test(gev_time_varying, gev_fix)
print(lrtresults)
#QUESTION E)
# Fit a GEV model with time-varying scale and shape parameters
gev_time_varying_scale_shape <- fevd(list_max_sea_levels, type = "GEV", time.units = "years", scale.fun = ~year, shape.fun = ~year)
# Plot the diagnostic plots for the time-varying scale and shape model
plot(gev_time_varying_scale_shape)
#Suite QUESTION E)
# Compare the model with time-varying scale and shape to the constant parameter model using LRT
lrt_result_scale_shape <- lr.test(gev_time_varying_scale_shape, gev_fix)
# View the LRT result
print(lrt_result_scale_shape)
# Determine the significance level (e.g., 0.05)
significance_level <- 0.05
# Compare the p-value to the significance level
if (lrt_result_scale_shape$p.value < significance_level) {
cat("The model with time-varying scale and shape parameters is preferred.\n")
} else {
cat("The constant parameter model is preferred.\n")
}
