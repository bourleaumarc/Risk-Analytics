# GEV model with varying time-location
gev_time_varying <- fevd(venice_max$max_sea_level, venice_max, type = "GEV", time.units= "year", location.fun = ~year)
plot(gev_time_varying) ; gev_time_varying$results$par ; return.level(gev_time_varying)
# Compare the two models using likelihood ratio test: Ho: no significant difference in model fit H1: there is a significant difference in model fit between the two models.
lr.test(gev_fix, gev_time_varying) # we can't reject the null hypothesis, this doesn't make sense..
lr.test(gev_fix, gev_time_varying) # we can't reject the null hypothesis, this doesn't make sense..
alpha <- 0.10  # 90% significance level
critical_value <- qchisq(1 - alpha, df = 1)  # Chi-squared critical value
lrt_result <- lr.test(gev_fix, gev_time_varying, critical = critical_value)
lrt_result
# Compare the two models using likelihood ratio test: Ho: no significant difference in model fit H1: there is a significant difference in model fit between the two models.
lr.test <- lr.test(gev_fix, gev_time_varying) # we can almost reject the null hypothesis at 95% significant level, which make sense as we have indications that the distribution is non-stationary
plot(lr.test)
# Compare the two models using likelihood ratio test: Ho: no significant difference in model fit H1: there is a significant difference in model fit between the two models.
lrt_result <- lr.test(gev_fix, gev_time_varying) # we can almost reject the null hypothesis at 95% significant level, which make sense as we have indications that the distribution is non-stationary
plot(lrt_result)
knitr::opts_chunk$set(echo = TRUE)
library(ismev)
library(VGAM)
library(tidyverse)
library(plotly)
library(plotrix)
library(scales)
library(extRemes)
# Read the Data
venice <- venice90
# Using block maxima approach to have the maximum sea level per year
venice_max <- venice %>%
group_by(year) %>%
summarise(max_sea_level = max(sealevel))
head(venice_max)
plot_ly(venice_max, x = ~year, y = ~max_sea_level, type = 'scatter', mode = 'markers', name = 'Max Value') %>% layout(title = "Maximum Value per year", xaxis = list(title="Year"), yaxis = list(title="Maximum Value"))  %>% add_segments(x = 1940, xend = 2009, y = 140, yend = 140, line = list(color = 'red', width = 2))
# Create linear model
mod1 <- lm(max_sea_level ~ year, data = venice_max)
summary(mod1)
# Predictions of 13 next years using the linear model
mod1_predict <- predict.lm(mod1,newdata=data.frame("year"=c(2010:2022)),se=T, interval = "confidence", level = 0.95)
mod1_predict
# Stored the predictions in a dataframe
venice_max_predict <- data.frame(
PredictedValues = mod1_predict) %>%
mutate(year = c(2010:2022))
head(venice_max_predict)
#Plot the confidence intervals
plotCI(x = venice_max_predict$year,
y = venice_max_predict$PredictedValues.fit.fit,
li = venice_max_predict$PredictedValues.fit.lwr,
ui = venice_max_predict$PredictedValues.fit.upr)
#Create a new dataframe for the extreme values of 2010 - 2022 (table from Wikipedia)
max_real <- data.frame(year = c(2012, 2012, 2013, 2018, 2019, 2019, 2019, 2022), max_sea_level = c(143, 149, 143, 156, 187, 144, 154, 204))
# Create the ggplot object
venice_plot <- ggplot() +
geom_point(data = max_real, aes(x = year, y = max_sea_level, color = "Observed"), alpha = 0.5, show.legend = TRUE, name = "Observed") +
geom_point(data = venice_max_predict, aes(x = year, y = PredictedValues.fit.fit, color = "Predicted"), shape = 1, show.legend = TRUE, name = "Predicted") +
labs(title = "Predicted Yearly Max Values vs Observed Values (>140cm)", x = "Year", y = "Sea Level") +
scale_x_continuous(breaks = unique(c(venice_max_predict$year, max_real$year))) +
scale_color_manual(name = "Data Type", values = c("Observed" = "red", "Predicted" = "black")) +
theme(legend.title = element_blank())
# Convert the ggplot object to a Plotly interactive plot
interactive_venice_plot <- ggplotly(venice_plot)
# Add the confidence interval as a separate trace
interactive_venice_plot <- interactive_venice_plot %>%
add_ribbons(data = venice_max_predict, x = ~year, ymin = ~PredictedValues.fit.lwr, ymax = ~PredictedValues.fit.upr, color = I("blue"), showlegend = TRUE, name = "Confidence Interval")
# Display the interactive plot
interactive_venice_plot
# First we unlist our data frame
list_max_sea_levels <- unlist(venice_max$max_sea_level)
# GEV model with fixed location
gev_fix <- fevd(list_max_sea_levels, type = "GEV", time.units= "year")
plot(gev_fix) ; gev_fix$results$par ; return.level(gev_fix) # shape is almost equal to 0.
# Compute confidence interval
ci(gev_fix, type= "parameter") # CI includes 0
# GEV model with varying time-location
gev_time_varying <- fevd(venice_max$max_sea_level, venice_max, type = "GEV", time.units= "year", location.fun = ~year)
plot(gev_time_varying) ; gev_time_varying$results$par ; return.level(gev_time_varying)
# Compare the two models using likelihood ratio test: Ho: no significant difference in model fit H1: there is a significant difference in model fit between the two models.
lrt_result <- lr.test(gev_fix, gev_time_varying) # we can almost reject the null hypothesis at 95% significant level, which make sense as we have indications that the distribution is non-stationary
plot(lrt_result)
lrt_result <- lr.test(gev_fix, gev_time_varying) # we can almost reject the null hypothesis at 95% significant level, which make sense as we have indications that the distribution is non-stationary
plot(lrt_result)
# Compare the two models using likelihood ratio test: Ho: no significant difference in model fit H1: there is a significant difference in model fit between the two models.
lrt_result2 <- lr.test(gev_fix, gev_time_varying) # we can almost reject the null hypothesis at 95% significant level, which make sense as we have indications that the distribution is non-stationary
plot(lrt_result_2)
# Compare the two models using likelihood ratio test: Ho: no significant difference in model fit H1: there is a significant difference in model fit between the two models.
lrt_result <- lr.test(gev_fix, gev_time_varying) # we can almost reject the null hypothesis at 95% significant level, which make sense as we have indications that the distribution is non-stationary
plot(lrt_result) # can't show diagnostic plot for some reason
View(lrt_result)
knitr::opts_chunk$set(echo = TRUE)
# Set initial parameters
initial_inventory <- 500
mean_sales <- 100
std_dev_sales <- 15
reorder_point <- 400
order_quantity <- 300
delivery_time <- 2
# Create vectors to store data
sales <- numeric(52)
deliveries <- numeric(52)
inventory <- numeric(52)
# Initialize variables
current_inventory <- initial_inventory
order_pending <- FALSE
weeks_to_delivery <- 2
# Simulation for 52 weeks
for (week in 1:52) {
# Simulate weekly sales
weekly_sales <- max(0, round(rnorm(1, mean_sales, std_dev_sales)))
# If demand exceeds inventory, limit sales to available stock
if (weekly_sales > current_inventory) {
weekly_sales <- current_inventory
}
# Update inventory
current_inventory <- current_inventory - weekly_sales
# Check if an order is needed
if (current_inventory < reorder_point && !order_pending) {
order_pending <- TRUE
weeks_to_delivery <- delivery_time
} else {
# Check if a delivery has arrived
if (weeks_to_delivery == 0 && order_pending) {
order_pending <- FALSE
current_inventory <- current_inventory + order_quantity
weeks_to_delivery <- -1  # Reset weeks_to_delivery to -1 to indicate that no more weeks need to be counted for this order
} else if (weeks_to_delivery > 0) {
weeks_to_delivery <- weeks_to_delivery - 1
}
}
# Store data for this week
sales[week] <- weekly_sales
deliveries[week] <- ifelse(weeks_to_delivery == 0 && order_pending, order_quantity, 0)
inventory[week] <- current_inventory
}
# Calculate totals
total_sales <- sum(sales)
total_orders_placed <- sum(ifelse(deliveries > 0, 1, 0))
final_inventory <- inventory[52]
# Create a data frame for the annual report
report <- data.frame(Week = 1:52, "Apples Sold" = sales, "Deliveries Received" = deliveries, "Remaining Inventory" = inventory)
# Display summary
cat("Total Apples Sold:", total_sales, "\n")
cat("Total Orders Placed:", total_orders_placed, "\n")
cat("Final Inventory:", final_inventory, "\n")
# Display annual report
print(report)
knitr::opts_chunk$set(echo = TRUE)
library(ismev)
library(VGAM)
library(tidyverse)
library(plotly)
library(plotrix)
library(scales)
library(extRemes)
# Read the Data
venice <- venice90
# Using block maxima approach to have the maximum sea level per year
venice_max <- venice %>%
group_by(year) %>%
summarise(max_sea_level = max(sealevel))
head(venice_max)
plot_ly(venice_max, x = ~year, y = ~max_sea_level, type = 'scatter', mode = 'markers', name = 'Max Value') %>% layout(title = "Maximum Value per year", xaxis = list(title="Year"), yaxis = list(title="Maximum Value"))  %>% add_segments(x = 1940, xend = 2009, y = 140, yend = 140, line = list(color = 'red', width = 2))
# Create linear model
mod1 <- lm(max_sea_level ~ year, data = venice_max)
summary(mod1)
# Predictions of 13 next years using the linear model
mod1_predict <- predict.lm(mod1,newdata=data.frame("year"=c(2010:2022)),se=T, interval = "confidence", level = 0.95)
mod1_predict
# Stored the predictions in a dataframe
venice_max_predict <- data.frame(
PredictedValues = mod1_predict) %>%
mutate(year = c(2010:2022))
head(venice_max_predict)
#Plot the confidence intervals
plotCI(x = venice_max_predict$year,
y = venice_max_predict$PredictedValues.fit.fit,
li = venice_max_predict$PredictedValues.fit.lwr,
ui = venice_max_predict$PredictedValues.fit.upr)
#Create a new dataframe for the extreme values of 2010 - 2022 (table from Wikipedia)
max_real <- data.frame(year = c(2012, 2012, 2013, 2018, 2019, 2019, 2019, 2022), max_sea_level = c(143, 149, 143, 156, 187, 144, 154, 204))
# Create the ggplot object
venice_plot <- ggplot() +
geom_point(data = max_real, aes(x = year, y = max_sea_level, color = "Observed"), alpha = 0.5, show.legend = TRUE, name = "Observed") +
geom_point(data = venice_max_predict, aes(x = year, y = PredictedValues.fit.fit, color = "Predicted"), shape = 1, show.legend = TRUE, name = "Predicted") +
labs(title = "Predicted Yearly Max Values vs Observed Values (>140cm)", x = "Year", y = "Sea Level") +
scale_x_continuous(breaks = unique(c(venice_max_predict$year, max_real$year))) +
scale_color_manual(name = "Data Type", values = c("Observed" = "red", "Predicted" = "black")) +
theme(legend.title = element_blank())
# Convert the ggplot object to a Plotly interactive plot
interactive_venice_plot <- ggplotly(venice_plot)
# Add the confidence interval as a separate trace
interactive_venice_plot <- interactive_venice_plot %>%
add_ribbons(data = venice_max_predict, x = ~year, ymin = ~PredictedValues.fit.lwr, ymax = ~PredictedValues.fit.upr, color = I("blue"), showlegend = TRUE, name = "Confidence Interval")
# Display the interactive plot
interactive_venice_plot
# First we unlist our data frame
list_max_sea_levels <- unlist(venice_max$max_sea_level)
# GEV model with fixed location
gev_fix <- fevd(list_max_sea_levels, type = "GEV", time.units= "year")
plot(gev_fix) ; gev_fix$results$par ; return.level(gev_fix) # shape is almost equal to 0.
# Compute confidence interval
ci(gev_fix, type= "parameter") # CI includes 0
# GEV model with varying time-location
gev_time_varying <- fevd(venice_max$max_sea_level, venice_max, type = "GEV", time.units= "year", location.fun = ~year)
plot(gev_time_varying) ; gev_time_varying$results$par ; return.level(gev_time_varying)
# Compare the two models using likelihood ratio test: Ho: no significant difference in model fit H1: there is a significant difference in model fit between the two models.
lrt_result <- lr.test(gev_fix, gev_time_varying) # we can almost reject the null hypothesis at 95% significant level, which make sense as we have indications that the distribution is non-stationary
plot(lrt_result) # can't show diagnostic plot for some reason
lrt_result
plot(gev_time_varying)
plot(gev_fix)
?lr.test
gev_time_varying_scale <- fevd(venice_max$max_sea_level, type = "GEV", time.units = "year", scale.fun = ~year, shape.fun = ~year)
gev_time_varying_scale <- fevd(list_max_sea_levels, type = "GEV", time.units = "year", scale.fun = ~year, shape.fun = ~year)
gev_time_varying_scale <- fevd(venice_max$max_sea_level, venice_max, type = "GEV", time.units = "year", scale.fun = ~year, shape.fun = ~year)
plot(gev_time_varying_scale)
lrt_result <- lr.test(gev_fix, gev_time_varying) # we can almost reject the null hypothesis at 95% significant level, which make sense as we have indications that the distribution is non-stationary
lrt_result
lrt_result2 <-lr.test(gev_fix, gev_time_varying, alpha = 0.1)
lrt_result2
lrt_result2 <-lr.test(gev_fix, gev_time_varying, alpha = 0.10)
lrt_result2
gev_time_varying_scale_shape <- fevd(venice_max$max_sea_level, venice_max, type = "GEV", time.units = "year", scale.fun = ~year, shape.fun = ~year)
plot(gev_time_varying_scale_shape)
# Fit a GEV model with time-varying scale and shape parameters
gev_time_varying_scale_shape <- fevd(venice_max$max_sea_level, venice_max, type = "GEV", time.units = "year", scale.fun = ~year, shape.fun = ~year, location.fun = ~year)
plot(gev_time_varying_scale_shape)
lrt_result <- lr.test(gev_fix, gev_time_varying_scale_shape) # we can almost reject the null hypothesis at 95% significant level, which make sense as we have indications that the distribution is non-stationary
lrt_result
# plot(lrt_result) # can't show diagnostic plot for some reason
########################################## ismev ##########################################
??ismev
# plot(lrt_result) # can't show diagnostic plot for some reason
########################################## ismev ##########################################
?gev_fit
# plot(lrt_result) # can't show diagnostic plot for some reason
########################################## ismev ##########################################
??gev_fit
library(ismev)
# plot(lrt_result) # can't show diagnostic plot for some reason
########################################## ismev ##########################################
?gev.fit
gev_fix_ismev <- gev.fit(venice_max, ydat = NULL)
View(venice_max)
gev_fix_ismev <- gev.fit(venice_max$max_sea_level, ydat = NULL)
gev_fix$results$par
gev_time_varying_ismev <- gev.fit(venice_max$max_sea_level, ydat = venice_max$year)
gev_fix_ismev <- gev.fit(venice_max$max_sea_level, ydat = NULL) # same parameters as extRemes
gev_time_varying_ismev <- gev.fit(venice_max$max_sea_level, ydat = venice_max$year)
time_varying_params <- list()
years <- unique(venice_max$year)
# Loop through each year and fit a GEV distribution
for (year in years) {
subset_data <- venice_max$year[venice_max$year == year]
params <- coef(fitgev(subset_data))
time_varying_params[[as.character(year)]] <- params
}
time_varying_params <- list()
years <- unique(venice_max$year)
# Loop through each year and fit a GEV distribution
for (year in years) {
subset_data <- venice_max$year[venice_max$year == year]
params <- coef(gev.fit(subset_data))
time_varying_params[[as.character(year)]] <- params
}
gev_fix_ismev <- gev.fit(venice_max$max_sea_level, ydat = NULL) # same parameters as extRemes
time_varying_params <- list()
years <- unique(venice_max$year)
# Loop through each year and fit a GEV distribution
for (year in years) {
subset_data <- venice_max$year[venice_max$year == year]
params <- coef(gev.fit(subset_data))
time_varying_params[[as.character(year)]] <- params
}
max
## Simulate Gumbel distribution
# Go through quantile function of the Gumbel distribution, using unif(0,1) variates
x <- runif(1000)
mu <- 1
beta <- 5
y <- mu-beta*log(-log(x))
plot(y, x) # cdf of a Gumbel distribution
seqx <- seq(-50, 50, by=0.1)
z <- (seqx-mu)/beta
plot(seqx, 1/beta*exp(-z-exp(-z)), type="l")
# You can do pretty much the same for the other extreme-value distributions
# Anderson-Darling test
library(DescTools)
AndersonDarlingTest(y, null="pGumbel", loc=mu, scale=beta)
# Fitting a GEV distribution to Gumbel observations
library(ismev)
mod0 <- gev.fit(y)
# Does it fit?
qqplot(rGumbel(length(y), loc=mu, scale=beta), y)
qqline(y, distribution=function(p) qGumbel(p, loc=mu, scale=beta))
# What about a distribution you might not know which domain of attraction it falls into?
library(lubridate)
obs.date <- seq(from=as.Date("1993-01-01", format = "%Y-%m-%d"), to=as.Date("2022-12-31", format = "%Y-%m-%d"), by="day")
obs <- rt(length(obs.date), df=1.5)
df <- data.frame(obs.date)
df <- data.frame(df, obs)
max <- data.frame(0, 0, 0)
years <- unique(year(df$obs.date))
months <- unique(month(df$obs.date))
for(i in 1:length(years)){
for(j in 1:length(months)){
subset <- df[(month(df$obs.date)==months[j])&(year(df$obs.date)==years[i]),]
max <- rbind(max, c(month=months[j], year=years[i], max(subset$obs)))
}
}
max <- max[-1, ]
colnames(max) <- c("month", "year", "maximum")
mod1 <- gev.fit(max$maximum)
gev.diag(mod1) #diagnostics plot
mod2 <- gev.fit(max$maximum, max, mul=2)
mod2
1-pchisq(-2*(mod2$nllh-mod1$nllh),1) #chi-square test
# The trend is not significant, this is expected!
## Data example
## Reproduced from great walkthrough by Hugo Winter
## available at: https://younghydrologicsociety.files.wordpress.com/2018/04/eva_training_exercises_egu_2018.pdf
data(rain) #from ismev
years <- rep(1:48, rep(c(365,365,366,365), times = 12))[-17532]
rain.ann.max <- unlist(lapply(X = split(rain,years), FUN = max))
# annual maxima from this set of data in South-West England
# from extRemes package, can use fevd()
library(extRemes)
mod3 <- fevd(rain.ann.max, type="GEV", time.units="years")
plot(mod3)
mod3$results$par #gives parameters of the GEV
# suggest heavy-tailed model here, but only point estimates.
# What about building confidence intervals?
ci.fevd(mod3, alpha=0.05, type="parameter")
# the CI includes 0 for the shape parameter, so not sure we're that heavy-tailed
gev.rl <- return.level(x = mod3, return.period = c(10,100,1000,10000),
do.ci = TRUE, alpha = 0.05)
gev.rl
#notice the very wide CI for the 10000-year return level.
# We clearly do not have enough data and the uncertainty
# concerning the shape parameter drives this.
## How to compute return levels (by hand) using GEV
# e.g. in the rain example, compute the 10-year return level
# understand here: the value exceeded one out of every 10 365-days block (1 year)
# approximated by
as.numeric(mod3$results$par[1]+mod3$results$par[2]*((-log(1-1/10))^(-mod3$results$par[3])-1)/mod3$results$par[3])
# or, as it is the 1-1/k = 1-1/10th quantile
qgev(1-1/10, location=mod3$results$par[1], scale=mod3$results$par[2], shape=mod3$results$par[3])
## Return period associated with level u
# recall: 1/(1-H(u))
as.numeric(1/(1-pgev(qgev(1-1/10, location=mod3$results$par[1], scale=mod3$results$par[2], shape=mod3$results$par[3]), location=mod3$results$par[1], scale=mod3$results$par[2], shape=mod3$results$par[3])))
# the above corresponds to 1/10 period as expected!
unique.years <- unique(years)
plot(unique.years, rain.ann.max)
# For simplicity: suppose you want to assess the number of blocks (years here) needed to exceed level 70, i.e. {Mn > 50}
as.numeric(1/(1-pgev(70, location=mod3$results$par[1], scale=mod3$results$par[2], shape=mod3$results$par[3])))
# you expect an average of 14.01 blocks (years) to wait before exceeding 70.
# making predictions with linear models (remainder)
mod4 <- lm(rain.ann.max~unique.years)
# making predictions for 5 years
predict.lm(mod4,newdata=data.frame("unique.years"=c(49:53)),se=T)
max
gev_time_varying_ismev <- gev.fit(venice_max$max_sea_level, venice_max, mul = 1)
gev_time_varying_ismev <- gev.fit(venice_max$max_sea_level, venice_max, mul = venice_max$year)
gev_time_varying_ismev <- gev.fit(venice_max$max_sea_level, venice_max, mul = 2)
gev_time_varying_ismev <- gev.fit(venice_max$max_sea_level, venice_max, ydat = TRUE, mul = 2)
gev_time_varying_ismev <- gev.fit(venice_max$max_sea_level, venice_max, ydat = venice_max$year, mul = 1)
plot(gev_fix) ; gev_fix$results$par ; return.level(gev_fix) # shape is almost equal to 0.
?lr.test
gev_fix$results$par
gev_time_varying$results$par
gev_time_varying$results$par
?fevd
TMX1
# GEV model with varying time-location
gev_time_varying <- fevd(venice_max$max_sea_level, venice_max, type = "GEV", time.units= "year", location.fun = ~sin(2 * pi * (year - 1940)/70) + cos(2 * pi * (year - 1940)/70))
gev_time_varying$results$par
lrt_result <- lr.test(gev_fix, gev_time_varying)
lrt_result
gev_time_varying_harmonic <- fevd(venice_max$max_sea_level, venice_max, type = "GEV", time.units= "year", location.fun = ~ year)
gev_time_varying_linear <- fevd(venice_max$max_sea_level, venice_max, type = "GEV", time.units= "year", location.fun = ~ year )
gev_time_varying_harmonic <- fevd(venice_max$max_sea_level, venice_max, type = "GEV", time.units= "year", location.fun = ~sin(2 * pi * (year - 1940)/70) + cos(2 * pi * (year - 1940)/70))
plot(gev_time_varying_harmonic)
plot(gev_time_varying_linear)
plot(gev_time_varying_linear) ; plot(gev_time_varying_harmonic)
lrt_result_linear <- lr.test(gev_fix, gev_time_varying_linear) # we can almost reject the null hypothesis at 95% significant level, which make sense as we have indications that the distribution is non-stationary
lrt_result_harmonic <-lr.test(gev_fix, gev_time_varying_harmonic)
lrt_result_linear
lrt_result_harmonic
gev_time_varying_harmonic$results$par
gev_fix$results$par
gev_time_varying_harmonic$results$par;
gev_time_varying_harmonic$results$par
plot(gev_time_varying_harmonic)
ci(gev_fix, type= "parameter") # CI includes 0
gev_time_varying_scale_shape <- fevd(venice_max$max_sea_level, venice_max, type = "GEV", time.units = "year", scale.fun = ~sin(2 * pi * (year - 1940)/70) + cos(2 * pi * (year - 1940)/70), shape.fun = ~sin(2 * pi * (year - 1940)/70) + cos(2 * pi * (year - 1940)/70), location.fun = ~sin(2 * pi * (year - 1940)/70) + cos(2 * pi * (year - 1940)/70))
plot(gev_time_varying_scale_shape)
plot(gev_time_varying_harmonic)
lrt_result <- lr.test(gev_fix, gev_time_varying_scale_shape) # we can almost reject the null hypothesis at 95% significant level, which make sense as we have indications that the distribution is non-stationary
lrt_result
lrt_result2 <- lr.test(gev_time_varying_harmonic, gev_time_varying_scale_shape)
lrt_result2
lrt_result <- lr.test(gev_fix, gev_time_varying_scale_shape)
lrt_result
lrt_result2 <- lr.test(gev_time_varying_harmonic, gev_time_varying_scale_shape)
lrt_result2
?lr.test
lrt_hand <- 1-pchisq(-2*(gev_time_varying_scale_shape$nllh-gev_fix$nllh),1)
lrt_hand
lrt_hand
1-pchisq(-2*(gev_time_varying_scale_shape$nllh-gev_fix$nllh),1)
gev_time_varying_scale_shape
mod2 <- gev.fit(max$maximum, max, mul=2)
mod2 <- gev.fit(max$maximum, max, mul=2)
mod2
gev_time_varying_scale_shape
gev_fix
1-pchisq(-2*( 290.2194 - 296.5808 ),1)
lrt_result <- lr.test(gev_fix, gev_time_varying_scale_shape) # we can almost reject the null hypothesis at 95% significant level, which make sense as we have indications that the distribution is non-stationary
lrt_result
gev.diag(mod1)
?gev.fit
##################################################### ismev ####################################################
gev_fix_ismev <- gev.fit(venice_max$max_sea_level)
gev_fix_ismev
gev_time_varying_scale_shape_ismev <- gev.fit(venice_max$max_sea_level, ydat = gev_fix_ismev$cov)
gev_time_varying_scale_shape_ismev <- gev.fit(venice_max$max_sea_level, ydat = gev_fix_ismev$cov)
gev_time_varying_scale_shape_ismev <-
gev_time_varying_scale_shape_ismev <- gev.fit(venice_max$max_sea_level, ydat = gev_fix_ismev$cov)
gev_time_varying_scale_shape_ismev <- gev.fit(venice_max$max_sea_level, ydat = gev_fix_ismev$cov, mul = 1, sigl = 2, shl = 3)
gev_time_varying_scale_shape
location_fun <- ~sin(2 * pi * (year - 1940)/70) + cos(2 * pi * (year - 1940)/70)
scale_fun <- ~sin(2 * pi * (year - 1940)/70) + cos(2 * pi * (year - 1940)/70)
shape_fun <- ~sin(2 * pi * (year - 1940)/70) + cos(2 * pi * (year - 1940)/70)
gev_time_varying_scale_shape_ismev <- gev.fit(venice_max$max_sea_level,  loc.fun = location_fun, sca.fun = scale_fun, shp.fun = shape_fun)
location_fun <- ~sin(2 * pi * (year - 1940)/70) + cos(2 * pi * (year - 1940)/70)
scale_fun <- ~sin(2 * pi * (year - 1940)/70) + cos(2 * pi * (year - 1940)/70)
shape_fun <- ~sin(2 * pi * (year - 1940)/70) + cos(2 * pi * (year - 1940)/70)
gev_time_varying_scale_shape_ismev <- gev.fit(venice_max$max_sea_level,  loc.fun = location_fun, sca.fun = scale_fun, shp.fun = shape_fun)
gev_time_varying_scale_shape_ismev
lrt_result_fix_scale_shape <- lr.test(gev_fix, gev_time_varying_scale_shape) # we can almost reject the null hypothesis at 95% significant level, which make sense as we have indications that the distribution is non-stationary
lrt_result_harmonic_scale_shape <- lr.test(gev_time_varying_harmonic, gev_time_varying_scale_shape)
lrt_result_fix_scale_shape
?lr.test
lrt_result_fix_scale_shape
plot(gev_time_varying_scale_shape)
lrt_result_harmonic_scale_shape <- lr.test(gev_time_varying_harmonic, gev_time_varying_scale_shape)
lrt_result_harmonic_scale_shape
# Fit a GEV model with time-varying scale and shape parameters
gev_time_varying_scale_shape_location <- fevd(venice_max$max_sea_level, venice_max, type = "GEV", time.units = "year", scale.fun = ~sin(2 * pi * (year - 1940)/70) + cos(2 * pi * (year - 1940)/70), shape.fun = ~sin(2 * pi * (year - 1940)/70) + cos(2 * pi * (year - 1940)/70), location.fun = ~sin(2 * pi * (year - 1940)/70) + cos(2 * pi * (year - 1940)/70))
# Plot the diagnostic plots for the time-varying scale and shape model
plot(gev_time_varying_scale_shape_location)
# Compare the two models using likelihood ratio test: Ho: simple model-->no significant difference in model fit H1: complex model -->there is a significant difference in model fit between the two models.
lrt_result_fix_scale_shape <- lr.test(gev_fix, gev_time_varying_scale_shape_location)
lrt_result_harmonic_scale_shape_location <- lr.test(gev_time_varying_harmonic, gev_time_varying_scale_shape_location)
lrt_result_harmonic_scale_shape_location
# Specify the years for which you want to predict return levels
years <- 2010:2022
# Calculate the return periods corresponding to each year
return_periods <- 1 / (1 - pnorm(1 - 1 / (years - min(years) + 1)))
# Predict return levels for each year
predicted_return_levels <- return.level(gev_time_varying_harmonic, return_periods)
```
gev_time_varying_harmonic
return.level(gev_time_varying_harmonic)
return.level(gev_time_varying_harmonic)
gev.rl <- return.level(x = gev_time_varying_harmonic, return.period = c(13),
do.ci = TRUE, alpha = 0.05)
?return.level
gev_time_varying_harmonic
gev.rl <- return.level(x = gev_time_varying_harmonic, return.period = c(13),
do.ci = TRUE, alpha = 0.05, qcov = gev_time_varying_harmonic$cov.data)
gev.rl <- return.level(x = gev_time_varying_harmonic, return.period = c(13),
do.ci = TRUE, alpha = 0.05, qcov = gev_time_varying_harmonic$cov)
gev_time_varying_harmonic$cov.data
gev_time_varying_harmonic
gev_time_varying_harmonic$cov.data
gev_time_varying_harmonic
attributes(gev_time_varying_harmonic)
gev.rl <- return.level(x = gev_time_varying_harmonic, return.period = c(13),
do.ci = TRUE, alpha = 0.05, qcov = gev_time_varying_harmonic$cov.data)
gev_time_varying_harmonic$cov.data
distill(gev_time_varying_harmonic, cov = TRUE)
cov_data <- distill(gev_time_varying_harmonic, cov = TRUE)
gev.rl <- return.level(x = gev_time_varying_harmonic, return.period = c(13),
do.ci = TRUE, alpha = 0.05, qcov = cov_data)
gev.rl <- return.level(x = gev_time_varying_harmonic, return.period = c(13),
do.ci = TRUE, alpha = 0.05, qcov = distill(gev_time_varying_harmonic, cov = TRUE))
cov_data <- distill(gev_time_varying_harmonic, cov = TRUE)
cov_data
gev.rl <- return.level(x = gev_time_varying_harmonic, return.period = c(13),
do.ci = TRUE, alpha = 0.05, qcov = cov_data)
cov_data
?distill
cov_data <- distill.matrix(gev_time_varying_harmonic, cov = TRUE)
cov_data <- distill.fevd(gev_time_varying_harmonic, cov = TRUE)
gev.rl <- return.level(x = gev_time_varying_harmonic, return.period = c(13),
do.ci = TRUE, alpha = 0.05, qcov = cov_data)
cov_data <- distill.list(gev_time_varying_harmonic, cov = TRUE)
gev.rl <- return.level(x = gev_time_varying_harmonic, return.period = c(13),
do.ci = TRUE, alpha = 0.05, qcov = cov_data)
View(cov_data)
cov_data <- distill.matrix(gev_time_varying_harmonic, cov = TRUE)
attributes(gev_time_varying_harmonic)
cov_data <- distill.matrix(gev_time_varying_harmonic, cov.data = TRUE)
?distill
?return.level
?return.level
return.level(gev_time_varying_harmonic)
gev_time_varying_harmonic
return.level(gev_time_varying_harmonic)
gev_time_varying_harmonic
return.level(gev_time_varying_harmonic)
gev_time_varying_harmonic
as.numeric(gev_time_varying_harmonic$results$par[1]+gev_time_varying_harmonic$results$par[4]*((-log(1-1/13))^(-gev_time_varying_harmonic$results$par[5])-1)/gev_time_varying_harmonic$results$par[5])
